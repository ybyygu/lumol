var N = null;var searchIndex = {};
searchIndex["lumol"]={"doc":"Lumol is a classical molecular simulation engine that provides a solid base for developing new algorithms and methods.","items":[[0,"units","lumol","This module allow to convert from and to the internal unit system.",N,N],[3,"CONVERSION_FACTORS","lumol::units","A map of conversion factors from various units to lumol internal units",N,N],[4,"ParseError","","Possible error causes when parsing an unit string.",N,N],[13,"Power","","Error while parsing a power in `x^y` expressions",0,N],[13,"Value","","Error while parsing the value part of an unit string",0,N],[13,"ParenthesesMismatch","","Parentheses are not balanced in this unit",0,N],[13,"NotFound","","This unit was not found",0,N],[12,"unit","lumol::units::ParseError","The unit that created this error",0,N],[13,"MalformedExpr","lumol::units","Any other error",0,N],[5,"from","","Convert the numeric value `val` from the unit `unit` to the internal unit.",N,[[["f64"],["str"]],["result",["f64","parseerror"]]]],[5,"from_str","","Parse the string `val` and convert it to the corresponding internal unit",N,[[["str"]],["result",["f64","parseerror"]]]],[5,"to","","Convert the numeric value `val` (in internal units) to the unit `unit`.",N,[[["f64"],["str"]],["result",["f64","parseerror"]]]],[0,"consts","lumol","Useful physical constants, expressed in the internal unit system.",N,N],[17,"K_BOLTZMANN","lumol::consts","Boltzmann constant",N,N],[17,"BOHR_RADIUS","","Bohr radius",N,N],[17,"AVOGADRO_NUMBER","","Avogadro number",N,N],[17,"FOUR_PI_EPSILON_0","","4 * π * epsilon_0",N,N],[0,"types","lumol","This module provides complexe numbers; 3D vectors and matrix; and multidimensional arrays for use in all other modules.",N,N],[3,"Complex","lumol::types","Complex number, with double precision real and imaginary parts.",N,N],[3,"Array2","","Two dimensional tensors, based on ndarray.",N,N],[3,"Matrix3","","A 3x3 square matrix type.",N,N],[3,"Vector3D","","A 3-dimensional vector type",N,N],[3,"Array3","","Three dimensional tensors, based on ndarray",N,N],[0,"energy","lumol","Interaction potentials for energy and forces computations",N,N],[8,"Potential","lumol::energy","A potential for force and energy computations.",N,N],[10,"energy","","Get the energy corresponding to the variable `x`",1,[[["self"],["f64"]],["f64"]]],[10,"force","","Get the force norm corresponding to the variable `x`",1,[[["self"],["f64"]],["f64"]]],[8,"PairPotential","","Marker trait for potentials that can be used for non-bonded two body interactions.",N,N],[11,"virial","","Compute the virial contribution corresponding to the distance `r` between the particles.",2,[[["self"],["vector3d"]],["matrix3"]]],[10,"tail_energy","","Compute the tail correction to the energy for the given cutoff.",2,[[["self"],["f64"]],["f64"]]],[10,"tail_virial","","Compute the tail correction to the virial for the given cutoff.",2,[[["self"],["f64"]],["f64"]]],[8,"BondPotential","","Marker trait for potentials that can be used for molecular bonds.",N,N],[11,"virial","","Compute the virial contribution corresponding to the distance `r` between the particles.",3,[[["self"],["vector3d"]],["matrix3"]]],[8,"AnglePotential","","Marker trait for potentials that can be used for molecular angles.",N,N],[8,"DihedralPotential","","Marker trait for potentials that can be used for molecular dihedral angles.",N,N],[3,"Buckingham","","Buckingham potential.",N,N],[12,"a","","Exponential term energetic constant",4,N],[12,"c","","`1/r^6` term energetic constant",4,N],[12,"rho","","Width of the exponential term length constant",4,N],[3,"CosineHarmonic","","Cosine harmonic potential.",N,N],[3,"Mie","","Mie potential.",N,N],[3,"Ewald","","Ewald summation for coulombic interactions.",N,N],[3,"PairInteraction","","A non-bonded interaction between two particle.",N,N],[4,"BondPath","","Shortest bond path between two particles in a system",N,N],[13,"None","","No bond path exists, the particles are not in the same molecule",5,N],[13,"SameParticle","","The two particles are the same one",5,N],[13,"OneBond","","The two particles are separated by one bond",5,N],[13,"TwoBonds","","The two particles are separated by two bonds",5,N],[13,"ThreeBonds","","The two particles are separated by three bonds",5,N],[13,"Far","","The two particles are in the same molecule and separated by more than three bonds",5,N],[8,"GlobalPotential","","A potential acting on the whole [System][System] at once.",N,N],[10,"cutoff","","Return the cut off radius.",6,[[["self"]],["option",["f64"]]]],[10,"energy","","Compute the energetic contribution of this potential",6,[[["self"],["configuration"]],["f64"]]],[10,"forces","","Compute the force contribution of this potential. This function should return a vector containing the force acting on each particle in the configuration.",6,N],[10,"atomic_virial","","Compute the total virial contribution of this potential, using the atomic virial definition",6,[[["self"],["configuration"]],["matrix3"]]],[11,"molecular_virial","","Compute the total virial contribution of this potential, using the molecular virial definition. This default to `atomic_virial`.",6,[[["self"],["configuration"]],["matrix3"]]],[3,"BornMayerHuggins","","Born-Mayer-Huggins potential.",N,N],[12,"a","","Exponential term energetic constant",7,N],[12,"c","","`1/r^6` term energetic constant",7,N],[12,"d","","`1/r^8` term energetic constant",7,N],[12,"sigma","","Sphere diameter length constant",7,N],[12,"rho","","Width of the exponential term length constant",7,N],[3,"TableComputation","","Computation of a potential using tabulated values.",N,N],[3,"Torsion","","Torsion potential.",N,N],[12,"k","","Force constant",8,N],[12,"delta","","Equilibrium value",8,N],[12,"n","","Multiplicity of the potential",8,N],[3,"NullPotential","","No-op potential.",N,N],[8,"GlobalCache","","Energetic cache for global potentials.",N,N],[10,"move_molecule_cost","","Get the cost of moving a rigid molecule in the system.",9,N],[10,"update","","Update the cache as needed after a call to `move_molecule_cost`.",9,N],[3,"Wolf","","Wolf summation for coulombic interactions.",N,N],[3,"Morse","","Morse potential",N,N],[12,"a","","Exponential term width value",10,N],[12,"x0","","Equilibrium value",10,N],[12,"depth","","Well depth value",10,N],[3,"LennardJones","","Lennard-Jones potential.",N,N],[12,"sigma","","Distance constant of the Lennard-Jones potential",11,N],[12,"epsilon","","Energy constant of the Lennard-Jones potential",11,N],[3,"RestrictionInfo","","Restriction information attached to a pair of `Particles` in a `System`.",N,N],[12,"excluded","","Is this pair excluded?",12,N],[12,"scaling","","Scaling factor for the potential. This value is contained between 0 and 1.",12,N],[3,"Gaussian","","Gaussian potential.",N,N],[4,"PairRestriction","","Possible restrictions on the pair interactions.",N,N],[13,"None","","No pair should be excluded.",13,N],[13,"IntraMolecular","","Only apply the interaction to intra-molecular pairs.",13,N],[13,"InterMolecular","","Only apply the interaction to inter-molecular pairs.",13,N],[13,"Exclude12","","Only apply the interaction to pairs which are not in 1-2 position (separated by one bond).",13,N],[13,"Exclude13","","Only apply the interaction to pairs which are not in 1-2 or 1-3 position (separated by one or two bonds).",13,N],[13,"Exclude14","","Only apply the interaction to pairs which are not in 1-2, 1-3 or 1-4 position (separated by one, two or three bonds).",13,N],[13,"Scale14","","Only apply the interaction to pairs which are not in 1-2 or 1-3 position, and scale the interaction for pairs in 1-4 position (separated by three bonds).",13,N],[8,"Computation","","Alternative energy and forces computation.",N,N],[10,"compute_energy","","Compute the energy value at `r`",14,[[["self"],["f64"]],["f64"]]],[10,"compute_force","","Compute the force value at `r`",14,[[["self"],["f64"]],["f64"]]],[8,"CoulombicPotential","","Electrostatic potential solver.",N,N],[10,"set_restriction","","Set the pair restriction scheme to use to the given `restriction`. All future call to `GlobalPotential::energy`, `GlobalPotential::force` or `GlobalPotential::virial` should use this restriction.",15,N],[3,"SharedEwald","","Thread-sade wrapper around Ewald implementing `CoulombicPotential`.",N,N],[3,"Harmonic","","Harmonic potential.",N,N],[12,"k","","Spring constant",16,N],[12,"x0","","Equilibrium value",16,N],[0,"sys","lumol","Representations of a simulated system",N,N],[0,"compute","lumol::sys","Algorithm to compute physical properties of a System",N,N],[8,"Compute","lumol::sys::compute","The `Compute` trait allow to compute properties of a system, without modifying this system. The `Output` type is the type of the computed property.",N,N],[16,"Output","","The data type of the property",17,N],[10,"compute","","Compute the property",17,N],[3,"Forces","","Compute all the forces acting on the system, and return a vector of force acting on each particles",N,N],[3,"PotentialEnergy","","Compute the potential energy of the system",N,N],[3,"KineticEnergy","","Compute the kinetic energy of the system",N,N],[3,"TotalEnergy","","Compute the total energy of the system",N,N],[3,"Temperature","","Compute the instantaneous temperature of the system",N,N],[3,"Volume","","Compute the volume of the system",N,N],[3,"AtomicVirial","","Compute the virial tensor of the system using the atomic definition.",N,N],[3,"MolecularVirial","","Compute the virial tensor of the system using the molecular definition",N,N],[3,"Virial","","Compute the virial tensor of the system, picking between [`AtomicVirial`] and [`MolecularVirial`] depending on the number of degrees of freedom simulated on the system.",N,N],[3,"PressureAtTemperature","","Compute the pressure of the system using the virial definition, at a given temperature.",N,N],[12,"temperature","","Temperature for the pressure computation",18,N],[3,"Pressure","","Compute the pressure of the system using the virial definition.",N,N],[3,"StressAtTemperature","","Compute the stress tensor of the system from the virial definition, at the given temperature.",N,N],[12,"temperature","","Temperature for the stress tensor computation",19,N],[3,"Stress","","Compute the stress tensor of the system from the virial definition",N,N],[3,"ParticleSlice","lumol::sys","A slice of `Particle`  inside a `ParticleVec`  .",N,N],[12,"name","","A slice of `name` from a `ParticleVec`",20,N],[12,"kind","","A slice of `kind` from a `ParticleVec`",20,N],[12,"charge","","A slice of `charge` from a `ParticleVec`",20,N],[12,"mass","","A slice of `mass` from a `ParticleVec`",20,N],[12,"position","","A slice of `position` from a `ParticleVec`",20,N],[12,"velocity","","A slice of `velocity` from a `ParticleVec`",20,N],[3,"Composition","","The system composition contains the number of particles of each kind in the system, as well as the number of molecules of each molecule type.",N,N],[3,"EnergyEvaluator","","An helper struct to evaluate energy components of a system.",N,N],[4,"CellShape","","The shape of a cell determine how we will be able to compute the periodic boundaries condition.",N,N],[13,"Infinite","","Infinite unit cell, with no boundaries",21,N],[13,"Orthorhombic","","Orthorhombic unit cell, with cuboid shape",21,N],[13,"Triclinic","","Triclinic unit cell, with arbitrary parallelepipedic shape",21,N],[3,"ParticleKind","","A particle kind. Particles with the same name will have the same kind. This is used for faster potential lookup.",N,N],[12,"0","","",22,N],[3,"Particle","","The Particle type hold basic data about a particle in the system. It is self contained, so that it will be easy to send data between parallels processes.",N,N],[12,"name","","Particle name.",23,N],[12,"kind","","Particle kind, an index for potentials lookup",23,N],[12,"charge","","Particle charge",23,N],[12,"mass","","Particle mass",23,N],[12,"position","","Particle positions",23,N],[12,"velocity","","Particle velocity, if needed",23,N],[3,"ParticlePtrMut","","An analog of a mutable pointer to `Particle`  with struct of array layout.",N,N],[12,"name","","A mutable pointer to a `name` from a `ParticleVec`",24,N],[12,"kind","","A mutable pointer to a `kind` from a `ParticleVec`",24,N],[12,"charge","","A mutable pointer to a `charge` from a `ParticleVec`",24,N],[12,"mass","","A mutable pointer to a `mass` from a `ParticleVec`",24,N],[12,"position","","A mutable pointer to a `position` from a `ParticleVec`",24,N],[12,"velocity","","A mutable pointer to a `velocity` from a `ParticleVec`",24,N],[3,"Bonding","","The basic building block for a topology. A `Bonding` contains data about the connectivity (bonds, angles, dihedrals) between particles in a single molecule.",N,N],[3,"Dihedral","","A `Dihedral` angle formed by the particles at indexes `i`, `j`, `k` and `m`",N,N],[3,"MoleculeIter","","An iterator over all the molecules in a `Configuration`",N,N],[5,"get_atomic_mass","","Get the mass of the element with the given atomic `name`",N,[[["str"]],["option",["f64"]]]],[5,"read_molecule","","Read a the first molecule from the file at `path`. If no bond information exists in the file, bonds are guessed.",N,[[["p"]],["result",["molecule","error"]]]],[3,"Bond","","A `Bond` between the particles at indexes `i` and `j`",N,N],[4,"OpenMode","","Possible modes when opening a `Trajectory`.",N,N],[13,"Read","","Open the file as read-only",25,N],[13,"Write","","Open the file as write-only, and overwrite any existing file",25,N],[13,"Append","","Open the file as read-write, keeping existing files",25,N],[3,"UnitCell","","An UnitCell defines the system physical boundaries.",N,N],[3,"Molecule","","A Molecule associate some particles bonded together.",N,N],[3,"ParticleVec","","An analog to `Vec<Particle>` with Struct of Array (SoA) layout",N,N],[12,"name","","A vector of `name` from a `Particle`",26,N],[12,"kind","","A vector of `kind` from a `Particle`",26,N],[12,"charge","","A vector of `charge` from a `Particle`",26,N],[12,"mass","","A vector of `mass` from a `Particle`",26,N],[12,"position","","A vector of `position` from a `Particle`",26,N],[12,"velocity","","A vector of `velocity` from a `Particle`",26,N],[3,"ParticlePtr","","An analog of a pointer to `Particle`  with struct of array layout.",N,N],[12,"name","","A pointer to a `name` from a `ParticleVec`",27,N],[12,"kind","","A pointer to a `kind` from a `ParticleVec`",27,N],[12,"charge","","A pointer to a `charge` from a `ParticleVec`",27,N],[12,"mass","","A pointer to a `mass` from a `ParticleVec`",27,N],[12,"position","","A pointer to a `position` from a `ParticleVec`",27,N],[12,"velocity","","A pointer to a `velocity` from a `ParticleVec`",27,N],[3,"MoleculeHash","","A molecule hash allow to identify a molecule from its atoms and bonds, and to know wether two molecules are the same without checking each atom and bond.",N,N],[3,"TrajectoryBuilder","","A `Trajectory` builder, to set some options before opening a trajectory.",N,N],[3,"BondDistances","","The `BondDistances` bitflag encode the topological distance between two particles in the molecule, i.e. the number of bonds between the particles. Two particles can have multiple bond path lionking them (in the case of cyclic molecules), which is why a bit flag is used instead of a single distance value.",N,N],[3,"Angle","","An `Angle` formed by the particles at indexes `i`, `j` and `k`",N,N],[3,"Configuration","","The `Configuration` contains the physical data of the system:",N,N],[12,"cell","","Unit cell of the system",28,N],[3,"TrajectoryError","","Possible error when reading and writing to trajectories",N,N],[4,"DegreesOfFreedom","","The number of degrees of freedom simulated in a given system",N,N],[13,"Particles","","All particles are explicitly simulated",29,N],[13,"Molecules","","All molecules are simulated as rigid bodies",29,N],[13,"Frozen","","All particles are explicitly simulated, but some degrees of freedom are frozen. The usize value is the number of frozen degree of freedom.",29,N],[3,"MoleculeRefMut","","An analog to [`&mut Molecule`] using particles stored elsewhere (in a system or an [`Molecule`]).",N,N],[3,"Trajectory","","A Trajectory is a file containing one or more successive simulation steps.",N,N],[3,"EnergyCache","","This is a cache for energy computation.",N,N],[3,"ParticleRefMut","","A mutable reference to a `Particle`  with struct of array layout.",N,N],[12,"name","","A mutable reference to a `name` from a `ParticleVec`",30,N],[12,"kind","","A mutable reference to a `kind` from a `ParticleVec`",30,N],[12,"charge","","A mutable reference to a `charge` from a `ParticleVec`",30,N],[12,"mass","","A mutable reference to a `mass` from a `ParticleVec`",30,N],[12,"position","","A mutable reference to a `position` from a `ParticleVec`",30,N],[12,"velocity","","A mutable reference to a `velocity` from a `ParticleVec`",30,N],[3,"ParticleSliceMut","","A mutable slice of `Particle`  inside a `ParticleVec`  .",N,N],[12,"name","","A mutable slice of `name` from a `ParticleVec`",31,N],[12,"kind","","A mutable slice of `kind` from a `ParticleVec`",31,N],[12,"charge","","A mutable slice of `charge` from a `ParticleVec`",31,N],[12,"mass","","A mutable slice of `mass` from a `ParticleVec`",31,N],[12,"position","","A mutable slice of `position` from a `ParticleVec`",31,N],[12,"velocity","","A mutable slice of `velocity` from a `ParticleVec`",31,N],[3,"MoleculeRef","","An analog to [`&Molecule`] using particles stored elsewhere (in a system or an [`Molecule`]).",N,N],[3,"MoleculeIterMut","","A mutable iterator over all the molecules in a `Configuration`",N,N],[3,"ParticleRef","","A reference to a `Particle`  with struct of array layout.",N,N],[12,"name","","A reference to a `name` from a `ParticleVec`",32,N],[12,"kind","","A reference to a `kind` from a `ParticleVec`",32,N],[12,"charge","","A reference to a `charge` from a `ParticleVec`",32,N],[12,"mass","","A reference to a `mass` from a `ParticleVec`",32,N],[12,"position","","A reference to a `position` from a `ParticleVec`",32,N],[12,"velocity","","A reference to a `velocity` from a `ParticleVec`",32,N],[3,"System","","The `System` type hold all the data about a simulated system.",N,N],[12,"simulated_degrees_of_freedom","","Number of degrees of freedom simulated in the system. This default to `DegreesOfFreedom::Particles`, and is set in the simulation setup.",33,N],[12,"step","","The current simulation step",33,N],[0,"sim","lumol","Type and algorithms for simulations",N,N],[0,"output","lumol::sim","Saving properties of a system during a simulation",N,N],[8,"Output","lumol::sim::output","The `Output` trait defines the interface for all the quantities outputted by the simulation during the run. An Output can be a text or a binary data file, an image, a text log, …",N,N],[11,"setup","","Function called once at the beginning of the simulation, which allows for some setup of the output if needed.",34,N],[10,"write","","Write the output from the system.",34,N],[11,"finish","","Function called once at the end of the simulation.",34,N],[4,"CustomOutputError","","Possible causes of error when using a custom output",N,N],[13,"Io","","Any IO error",35,N],[13,"Expr","","Error in the mathematical expression",35,N],[13,"Custom","","Any other error",35,N],[3,"TrajectoryOutput","","The `TrajectoryOutput` allows to write the trajectory of the system to a file, using any format supported by the [Chemfiles][chemfiles] library.",N,N],[3,"CellOutput","","The `CellOutput` writes all the components of a cell to a file . The columns in the file contain the following values: `step A B C α β γ`.",N,N],[3,"StressOutput","","The `StressOutput` writes the stress of the system to a text file, organized as: `step stress.xx stress.yy stress.zz stress.xy stress.xz stress.yz`.",N,N],[3,"ForcesOutput","","The `ForcesOutput` writes the forces acting on the atoms using XYZ format",N,N],[3,"PropertiesOutput","","The `PropertiesOutput` write various physical properties of the system to a file. These properties are:",N,N],[3,"CustomOutput","","The `CustomOutput` writes data into a file from an user-provided template.",N,N],[3,"EnergyOutput","","The `EnergyOutput` writes the energy of the system to a text file, organized as: `steps PotentialEnergy KineticEnergy TotalEnergy`.",N,N],[0,"md","lumol::sim","Molecular dynamics algorithms.",N,N],[3,"RescaleThermostat","lumol::sim::md","Velocity rescaling thermostat.",N,N],[8,"Thermostat","","Trait for controls usable as thermostats",N,N],[3,"RemoveTranslation","","Remove global translation from the system",N,N],[3,"MolecularDynamics","","Molecular Dynamics propagator for the simulation.",N,N],[3,"LeapFrog","","Leap-frog integrator. This one is reversible and symplectic.",N,N],[3,"Verlet","","Verlet integrator. This one is reversible and symplectic.",N,N],[3,"BerendsenBarostat","","Berendsen barostat integrator based on velocity-Verlet. This one neither reversible nor symplectic.",N,N],[3,"AnisoBerendsenBarostat","","Anisotropic Berendsen barostat integrator based on velocity-Verlet. This one neither reversible nor symplectic.",N,N],[8,"Control","","Trait for controlling some parameters in a system during a simulation.",N,N],[11,"setup","","Function called once at the beginning of the simulation, which allow for some setup of the control algorithm if needed.",36,N],[10,"control","","Do your job, control algorithm!",36,N],[11,"finish","","Function called once at the end of the simulation.",36,N],[3,"BerendsenThermostat","","Berendsen thermostat.",N,N],[3,"VelocityVerlet","","Velocity-Verlet integrator. This one is reversible and symplectic.",N,N],[3,"RemoveRotation","","Remove global rotation from the system",N,N],[3,"Rewrap","","Rewrap all molecules' centers of mass to lie within the unit cell. Individual atoms in a molecule may still lie outside of the cell.",N,N],[8,"Integrator","","The `Integrator` trait define integrator interface for molecular dynamics. An integrator is an algorithm responsible for propagating the equations of motion in the system.",N,N],[11,"setup","","Setup the integrator. This function is called once by every simulation run.",37,N],[10,"integrate","","Integrate the equations of motion. This is called at every step of the simulation.",37,N],[0,"mc","lumol::sim","Monte Carlo Metropolis algorithms",N,N],[3,"MonteCarlo","lumol::sim::mc","Metropolis Monte Carlo propagator",N,N],[4,"MCDegreeOfFreedom","","Possible degrees of freedom simulated by a given Monte Carlo move",N,N],[13,"AllMolecules","","All molecules are simulated",38,N],[13,"Molecules","","All molecules with a molecule type in the `BTreeSet` are simulated",38,N],[13,"Particles","","All the particles are simulated",38,N],[3,"Translate","","Monte Carlo move for translating a molecule",N,N],[3,"Resize","","Monte Carlo move that changes the size of the simulation cell",N,N],[3,"Rotate","","Monte Carlo move for rotating a rigid molecule",N,N],[8,"MCMove","","The `MCMove` trait correspond to the set of methods used in Monte Carlo simulations.",N,N],[10,"describe","","Give a short description of this move",39,[[["self"]],["str"]]],[10,"setup","","Set up move before simulation is run",39,N],[10,"degrees_of_freedom","","Get the number of degrees of freedom simulated by this move",39,[[["self"]],["mcdegreeoffreedom"]]],[10,"prepare","","Prepare the move by selecting the particles to move, and the parameters of the move. The `rng` random number generator should be used to generate the parameters of the move.",39,[[["self"],["system"],["rngcore"]],["bool"]]],[10,"cost","","Get the cost of performing this move on `system`. For example in simple NVT simulations, this cost is the energetic difference between the new and the old state times beta. The cost must be dimmensionless.",39,[[["self"],["system"],["f64"],["energycache"]],["f64"]]],[10,"apply","","Apply the move, if it has not already been done in `prepare`.",39,N],[10,"restore","","Restore the system to it's initial state if it has been changed in `prepare`.",39,N],[10,"update_amplitude","","Update the sample range for displacements.",39,N],[3,"MoveCounter","","This struct keeps track of the number of times a move was called and how often it was accepted.",N,N],[12,"total_attempted","","Count the total number of times the move was called.",40,N],[12,"total_accepted","","Count the total number of times the move was accepted.",40,N],[12,"accepted","","Count the number of times the move was accepted since the last update.",40,N],[12,"attempted","","Count the number of times the move was called since the last update.",40,N],[0,"min","lumol::sim","Energy minimization algorithms",N,N],[3,"Minimization","lumol::sim::min","Minimization propagator for simulations.",N,N],[8,"Minimizer","","The `Minimizer` trait define minimization interface.",N,N],[11,"setup","","Setup the minimizer. This function is called once at the begining of every simulation run.",41,N],[10,"minimize","","Find a new configuration of lower energy, and return the corresponding values for energy and forces.",41,[[["self"],["system"]],["tolerance"]]],[10,"degrees_of_freedom","","Get the number of degrees of freedom simulated by this minimizer",41,[[["self"],["system"]],["degreesoffreedom"]]],[3,"Tolerance","","Tolerance criteria used for energy minimization",N,N],[12,"energy","","Potential energy of the system",42,N],[12,"force2","","Maximal squared norm of the force acting on an atom",42,N],[3,"SteepestDescent","","Steepest descent minimization algorithm.",N,N],[4,"TemperatureStrategy","lumol::sim","Possible temperature computation strategies. Different propagators needs different ways to compute the temperature: Monte Carlo temperature is a constant of the simulation, whereas for molecular dynamics we use the instantaneous velocities.",N,N],[13,"None","","No specific strategy, use whatever strategy was already in use.",43,N],[13,"Velocities","","Use the instantaneous velocities to compute the temperature",43,N],[13,"External","","Use a fixed external temperature",43,N],[3,"BoltzmannVelocities","","Initialize the velocities from a Boltzmann distribution.",N,N],[3,"UniformVelocities","","Initialize the velocities from an uniform distribution.",N,N],[8,"Propagator","","The propagator trait is the main algorithm of a simulation, i.e. the one which update the system. The main function here is `propagate`, which should propagate the simulation for one step.",N,N],[10,"temperature_strategy","","Get the temperature computation strategy for this propagator.",44,[[["self"]],["temperaturestrategy"]]],[10,"degrees_of_freedom","","Get the number of degrees of freedom simulated by this propagator",44,[[["self"],["system"]],["degreesoffreedom"]]],[11,"setup","","Setup code, preparing all the meta-information needed about the simulation.",44,N],[10,"propagate","","Propagate the system for one simulation step.",44,N],[11,"finish","","Finish the simulation, and maybe output some information about it",44,N],[8,"InitVelocities","","A method to initialize the velocities of a system.",N,N],[10,"init","","Initialize the velocities of the system.",45,N],[10,"seed","","Set the seed of the random number generator. The default seed is 42.",45,N],[3,"Simulation","","The Simulation struct holds all the needed algorithms for running the simulation. It should be use together with a `System` to perform the simulation.",N,N],[0,"input","lumol","This module provide a way to build a Lumol simulation using input files.",N,N],[8,"FromToml","lumol::input","Convert a TOML table to a Rust type.",N,N],[10,"from_toml","","Do the conversion from `table` to Self.",46,[[["btreemap"]],["result",["error"]]]],[8,"FromTomlWithData","","Convert a TOML table and some additional owned data to a Rust type.",N,N],[16,"Data","","The type of the additional data needed.",47,N],[10,"from_toml","","Do the conversion from `table` and `data` to Self.",47,N],[8,"FromTomlWithRefData","","Convert a TOML table to a Rust type using information from an additional reference.",N,N],[16,"Data","","The type of the additional data needed.",48,N],[10,"from_toml","","Do the conversion from `table` and `data` to Self.",48,N],[3,"Input","","An input file for Lumol.",N,N],[5,"setup_default_logger","","Setup a default logger to be able to print error messages",N,N],[3,"Config","","A configuration about how to run a single simulation. This contains the system to simulate, the simulation itself and the number of steps to run the simulation.",N,N],[12,"system","","The simulated system",49,N],[12,"simulation","","The simulation object",49,N],[12,"nsteps","","The simulation duration",49,N],[6,"Result","","Custom `Result` type for input files",N,N],[3,"InteractionsInput","","Input file for reading interactions",N,N],[4,"Error","","Possible causes of error when reading input files",N,N],[13,"TOML","","Error in the TOML input file",50,N],[13,"Io","","IO error, and associated file path",50,N],[13,"Trajectory","","Error while reading a trajectory file",50,N],[13,"Config","","File content error: missing sections, bad data types",50,N],[13,"Unit","","Unit parsing error",50,N],[13,"CustomOutput","","Specific error from the custom outputs",50,N],[7,"VERSION","lumol","The full version of the crate, containing git state if available",N,N],[11,"bitand","lumol::sys","Returns the intersection between the two sets of flags.",51,[[["self"],["bonddistances"]],["bonddistances"]]],[11,"description","","",52,[[["self"]],["str"]]],[11,"description","lumol::units","",0,[[["self"]],["str"]]],[11,"fmt","lumol::sys","",51,[[["self"],["formatter"]],["result",["error"]]]],[11,"neg","lumol::types","",53,[[["self"]],["vector3d"]]],[11,"neg","","",54,[[["self"]],["complex"]]],[11,"deref_mut","","",53,N],[11,"deref_mut","","",55,[[["self"]],["arraybase"]]],[11,"deref_mut","lumol::sys","",33,[[["self"]],["configuration"]]],[11,"deref_mut","lumol::types","",56,N],[11,"deref_mut","","",57,[[["self"]],["arraybase"]]],[11,"default","","",54,[[],["complex"]]],[11,"default","","",53,[[],["vector3d"]]],[11,"default","lumol::sys","",51,[[],["bonddistances"]]],[11,"index_mut","lumol::types","",57,N],[11,"index_mut","","",55,N],[11,"index","","",55,N],[11,"index","","",57,N],[11,"mul","","",56,[[["self"],["vector3d"]],["vector3d"]]],[11,"mul","","",56,[[["self"],["vector3d"]],["vector3d"]]],[11,"mul","","",54,[[["self"],["f64"]],["complex"]]],[11,"mul","","",53,[[["self"],["f64"]],["vector3d"]]],[11,"mul","","",53,[[["self"],["vector3d"]],["f64"]]],[11,"mul","","",56,[[["self"],["vector3d"]],["vector3d"]]],[11,"mul","","",56,[[["self"],["matrix3"]],["matrix3"]]],[11,"mul","","",56,[[["self"],["f64"]],["matrix3"]]],[11,"mul","","",54,[[["self"],["complex"]],["complex"]]],[11,"mul","","",56,[[["self"],["matrix3"]],["matrix3"]]],[11,"mul","","",53,[[["self"],["vector3d"]],["f64"]]],[11,"mul","","",53,[[["self"],["vector3d"]],["f64"]]],[11,"mul","","",56,[[["self"],["matrix3"]],["matrix3"]]],[11,"add","","",53,[[["self"],["vector3d"]],["vector3d"]]],[11,"add","","",56,[[["self"],["matrix3"]],["matrix3"]]],[11,"add","","",53,[[["self"],["vector3d"]],["vector3d"]]],[11,"add","","",56,[[["self"],["matrix3"]],["matrix3"]]],[11,"add","","",54,[[["self"],["complex"]],["complex"]]],[11,"add","","",53,[[["self"],["vector3d"]],["vector3d"]]],[11,"add","","",56,[[["self"],["matrix3"]],["matrix3"]]],[11,"compute","lumol::sys::compute","",58,[[["self"],["system"]],["f64"]]],[11,"compute","","",59,[[["self"],["system"]],["f64"]]],[11,"compute","","",60,[[["self"],["system"]],["f64"]]],[11,"compute","","",61,[[["self"],["system"]],["f64"]]],[11,"compute","","",62,[[["self"],["system"]],["matrix3"]]],[11,"compute","","",18,[[["self"],["system"]],["f64"]]],[11,"compute","","",63,[[["self"],["system"]],["matrix3"]]],[11,"compute","","",64,[[["self"],["system"]],["matrix3"]]],[11,"compute","","",65,[[["self"],["system"]],["matrix3"]]],[11,"compute","","",66,[[["self"],["system"]],["vec",["vector3d"]]]],[11,"compute","","",19,[[["self"],["system"]],["matrix3"]]],[11,"compute","","",67,[[["self"],["system"]],["f64"]]],[11,"compute","","",68,[[["self"],["system"]],["f64"]]],[11,"bitor","lumol::sys","Returns the union of the two sets of flags.",51,[[["self"],["bonddistances"]],["bonddistances"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result",["error"]]]],[11,"new","","Create a new empty `Configuration`",28,[[],["configuration"]]],[11,"are_in_same_molecule","","Check if the particles at indexes `i` and `j` are in the same molecule",28,[[["self"],["usize"],["usize"]],["bool"]]],[11,"molecules","","Get an iterator over the molecules in the configuration.",28,[[["self"]],["moleculeiter"]]],[11,"molecules_mut","","Get an iterator over the molecules in the configuration.",28,[[["self"]],["moleculeitermut"]]],[11,"molecule","","Get the molecule at index `id`",28,[[["self"],["usize"]],["moleculeref"]]],[11,"molecule_mut","","Get the molecule at index `id`",28,[[["self"],["usize"]],["moleculerefmut"]]],[11,"molecule_id","","Get the index of the molecule containing the particle `i`",28,[[["self"],["usize"]],["usize"]]],[11,"bond_path","","Get the length of the shortest bond path to go from the particle `i` to the particle `j`. If the particles are not in the same molecule, the length is -1. Else, this length is 0 if `i == j`, 1 if there is a bond between `i` and `j`, etc.",28,[[["self"],["usize"],["usize"]],["bondpath"]]],[11,"remove_molecule","","Remove the molecule at index `i`",28,N],[11,"add_bond","","Add a bond between the particles at indexes `i` and `j`. The particles should have been added to the configuration before calling this.",28,[[["self"],["usize"],["usize"]],["vec"]]],[11,"add_molecule","","Add a molecule to the configuration, putting the new particles at the end of the particles list",28,N],[11,"size","","Get the number of particles in this configuration",28,[[["self"]],["usize"]]],[11,"is_empty","","Check if this configuration contains any particle",28,[[["self"]],["bool"]]],[11,"center_of_mass","","Return the center-of-mass of the configuration",28,[[["self"]],["vector3d"]]],[11,"particles","","Get the list of particles in this configuration, as a `ParticleSlice`.",28,[[["self"]],["particleslice"]]],[11,"particles_mut","","Get the list of particles in this configuration, as a mutable `ParticleSliceMut`.",28,[[["self"]],["particleslicemut"]]],[11,"distance","","Get the distance between the particles at indexes `i` and `j`",28,[[["self"],["usize"],["usize"]],["f64"]]],[11,"nearest_image","","Get the vector between the nearest image of particle `j` with respect to particle `i`.",28,[[["self"],["usize"],["usize"]],["vector3d"]]],[11,"angle","","Get the angle between the particles `i`, `j` and `k`",28,[[["self"],["usize"],["usize"],["usize"]],["f64"]]],[11,"angle_and_derivatives","","Get the angle and the derivatives of the angle between the particles `i`, `j` and `k`",28,N],[11,"dihedral","","Get the dihedral angle between the particles `i`, `j`, `k` and `m`",28,[[["self"],["usize"],["usize"],["usize"],["usize"]],["f64"]]],[11,"dihedral_and_derivatives","","Get the dihedral angle and the derivatives of the dihedral angle between the particles `i`, `j`, `k` and `m`",28,N],[11,"deref","","",33,[[["self"]],["configuration"]]],[11,"deref","lumol::types","",53,N],[11,"new","lumol::sys","Create a new `Bonding` containing only the atom i",69,[[["usize"]],["bonding"]]],[11,"size","","Get the number of atoms in the molecule",69,[[["self"]],["usize"]]],[11,"start","","Get the first atom of this molecule",69,[[["self"]],["usize"]]],[11,"end","","Get the index of the first atom after this molecule",69,[[["self"]],["usize"]]],[11,"contains","","Does this molecule contains the particle `i`",69,[[["self"],["usize"]],["bool"]]],[11,"merge_with","","Merge this molecule with `other`. The first particle in `other` should be the particle just after the last one in `self`.",69,N],[11,"translate_by","","Translate all indexes in this molecule by `delta`.",69,N],[11,"add_bond","","Add a bond between the particles at indexes `i` and `j`. These particles are assumed to be in the molecule",69,N],[11,"remove_particle","","Removes particle at index `i` and any associated bonds, angle or dihedral. This function also update the indexes for the bonds/angles/dihedral by remove 1 to all the values `> i`",69,N],[11,"bonds","","Get the internal list of bonds",69,[[["self"]],["hashset"]]],[11,"angles","","Get the internal list of angles",69,[[["self"]],["hashset"]]],[11,"dihedrals","","Get the internal list of dihedrals",69,[[["self"]],["hashset"]]],[11,"bond_distances","","Get the all the possible bond paths the particles `i` and `j` in this molecule",69,[[["self"],["usize"],["usize"]],["bonddistances"]]],[11,"indexes","","Get the indexes of the particles in this molecule. All atoms in the returned range are inside this molecule.",69,[[["self"]],["range",["usize"]]]],[11,"deref","","",70,N],[11,"deref","lumol::types","",55,[[["self"]],["arraybase"]]],[11,"deref","lumol::sys","",71,N],[11,"deref","","",72,N],[11,"deref","lumol::units","",73,[[["self"]],["btreemap"]]],[11,"deref","lumol::types","",56,N],[11,"deref","","",57,[[["self"]],["arraybase"]]],[11,"deref","lumol::energy","",74,[[["self"]],["ewaldparameters"]]],[11,"fmt","lumol::sys","",51,[[["self"],["formatter"]],["result",["error"]]]],[11,"div_assign","lumol::types","",53,N],[11,"div_assign","","",56,N],[11,"div_assign","","",53,N],[11,"div_assign","","",53,N],[11,"div_assign","","",54,N],[11,"div_assign","","",56,N],[11,"div_assign","","",54,N],[11,"div_assign","","",56,N],[11,"extend","lumol::sys","",51,N],[11,"div","lumol::types","",54,[[["self"],["f64"]],["complex"]]],[11,"div","","",56,[[["self"],["f64"]],["matrix3"]]],[11,"div","","",54,[[["self"],["complex"]],["complex"]]],[11,"div","","",53,[[["self"],["f64"]],["vector3d"]]],[11,"set_restriction","lumol::energy","",75,N],[11,"set_restriction","","",76,N],[11,"bitxor_assign","lumol::sys","Toggles the set of flags.",51,N],[11,"bitor_assign","","Adds the set of flags.",51,N],[11,"move_molecule_cost","lumol::energy","",76,N],[11,"update","","",76,N],[11,"move_molecule_cost","","",75,N],[11,"update","","",75,N],[11,"fmt","lumol::sys","",22,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::units","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"next_back","lumol::sys","",77,[[["self"]],["option"]]],[11,"next_back","","",78,[[["self"]],["option"]]],[11,"next","","",78,[[["self"]],["option"]]],[11,"size_hint","","",78,N],[11,"count","","",78,[[["self"]],["usize"]]],[11,"next","","",77,[[["self"]],["option"]]],[11,"size_hint","","",77,N],[11,"count","","",77,[[["self"]],["usize"]]],[11,"cutoff","lumol::energy","",76,[[["self"]],["option",["f64"]]]],[11,"energy","","",76,[[["self"],["configuration"]],["f64"]]],[11,"forces","","",76,N],[11,"atomic_virial","","",76,[[["self"],["configuration"]],["matrix3"]]],[11,"molecular_virial","","",76,[[["self"],["configuration"]],["matrix3"]]],[11,"cutoff","","",75,[[["self"]],["option",["f64"]]]],[11,"energy","","",75,[[["self"],["configuration"]],["f64"]]],[11,"forces","","",75,N],[11,"atomic_virial","","",75,[[["self"],["configuration"]],["matrix3"]]],[11,"molecular_virial","","",75,[[["self"],["configuration"]],["matrix3"]]],[11,"clone","lumol::types","",53,[[["self"]],["vector3d"]]],[11,"clone","lumol::energy","",79,[[["self"]],["cosineharmonic"]]],[11,"clone","","",4,[[["self"]],["buckingham"]]],[11,"clone","lumol::sys","",27,[[["self"]],["particleptr"]]],[11,"clone","","",69,[[["self"]],["bonding"]]],[11,"clone","","",51,[[["self"]],["bonddistances"]]],[11,"clone","lumol::energy","",80,[[["self"]],["tablecomputation"]]],[11,"clone","lumol::sys","",28,[[["self"]],["configuration"]]],[11,"clone","lumol::energy","",8,[[["self"]],["torsion"]]],[11,"clone","","",81,[[["self"]],["mie"]]],[11,"clone","lumol::sys","",72,[[["self"]],["molecule"]]],[11,"clone","","",32,[[["self"]],["particleref"]]],[11,"clone","lumol::energy","",74,[[["self"]],["ewald"]]],[11,"clone","lumol::sys","",82,[[["self"]],["composition"]]],[11,"clone","lumol::energy","",83,[[["self"]],["gaussian"]]],[11,"clone","lumol::sys","",84,[[["self"]],["moleculehash"]]],[11,"clone","lumol::energy","",11,[[["self"]],["lennardjones"]]],[11,"clone","lumol::types","",56,[[["self"]],["matrix3"]]],[11,"clone","","",54,[[["self"]],["complex"]]],[11,"clone","","",57,[[["self"]],["array3"]]],[11,"clone","lumol::sys","",21,[[["self"]],["cellshape"]]],[11,"clone","lumol::energy","",85,[[["self"]],["nullpotential"]]],[11,"clone","","",7,[[["self"]],["bornmayerhuggins"]]],[11,"clone","lumol::sys","",86,[[["self"]],["unitcell"]]],[11,"clone","","",23,[[["self"]],["particle"]]],[11,"clone","lumol::energy","",16,[[["self"]],["harmonic"]]],[11,"clone","lumol::sys","",20,[[["self"]],["particleslice"]]],[11,"clone","lumol::energy","",13,[[["self"]],["pairrestriction"]]],[11,"clone","","",10,[[["self"]],["morse"]]],[11,"clone","lumol::sys","",29,[[["self"]],["degreesoffreedom"]]],[11,"clone","lumol::energy","",75,[[["self"]],["sharedewald"]]],[11,"clone","","",12,[[["self"]],["restrictioninfo"]]],[11,"clone","","",76,[[["self"]],["wolf"]]],[11,"clone","","",5,[[["self"]],["bondpath"]]],[11,"clone","lumol::types","",55,[[["self"]],["array2"]]],[11,"clone","lumol::sys","",26,[[["self"]],["particlevec"]]],[11,"clone","","",87,[[["self"]],["dihedral"]]],[11,"clone","","",33,[[["self"]],["system"]]],[11,"clone","lumol::energy","",88,[[["self"]],["pairinteraction"]]],[11,"clone","lumol::sys","",22,[[["self"]],["particlekind"]]],[11,"clone","","",89,[[["self"]],["bond"]]],[11,"clone","","",90,[[["self"]],["angle"]]],[11,"clone","","",24,[[["self"]],["particleptrmut"]]],[11,"fmt","","",86,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",87,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::energy","",12,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::sys","",72,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",84,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::units","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::sys","",89,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::energy","",13,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::types","",56,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::sys","",71,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::types","",54,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::sys","",82,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",90,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::types","",53,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",55,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::energy","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::sys","",52,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",69,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",70,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::types","",57,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::sys","",24,[[["self"],["formatter"]],["result",["error"]]]],[11,"into_iter","","",31,N],[11,"into_iter","","",20,N],[11,"sub","lumol::types","",53,[[["self"],["vector3d"]],["vector3d"]]],[11,"sub","","",56,[[["self"],["matrix3"]],["matrix3"]]],[11,"sub","","",56,[[["self"],["matrix3"]],["matrix3"]]],[11,"sub","","",54,[[["self"],["complex"]],["complex"]]],[11,"sub","lumol::sys","Returns the set difference of the two sets of flags.",51,[[["self"],["bonddistances"]],["bonddistances"]]],[11,"sub","lumol::types","",56,[[["self"],["matrix3"]],["matrix3"]]],[11,"sub","","",53,[[["self"],["vector3d"]],["vector3d"]]],[11,"sub","","",53,[[["self"],["vector3d"]],["vector3d"]]],[11,"cmp","lumol::sys","",22,[[["self"],["particlekind"]],["ordering"]]],[11,"cmp","","",89,[[["self"],["bond"]],["ordering"]]],[11,"cmp","","",84,[[["self"],["moleculehash"]],["ordering"]]],[11,"cmp","","",51,[[["self"],["bonddistances"]],["ordering"]]],[11,"from_iter","","",51,[[["t"]],["bonddistances"]]],[11,"compute_energy","lumol::energy","",80,[[["self"],["f64"]],["f64"]]],[11,"compute_force","","",80,[[["self"],["f64"]],["f64"]]],[11,"one","lumol::types","",54,[[],["complex"]]],[11,"one","","Create an identity matrix",56,[[],["matrix3"]]],[11,"add_assign","","",53,N],[11,"add_assign","","",54,N],[11,"add_assign","","",56,N],[11,"add_assign","","",56,N],[11,"add_assign","","",53,N],[11,"add_assign","","",56,N],[11,"add_assign","","",53,N],[11,"sum","","",56,[[["i"]],["matrix3"]]],[11,"mul_assign","","",53,N],[11,"mul_assign","","",56,N],[11,"mul_assign","","",56,N],[11,"mul_assign","","",53,N],[11,"mul_assign","","",54,N],[11,"mul_assign","","",56,N],[11,"mul_assign","","",53,N],[11,"mul_assign","","",54,N],[11,"mul_assign","","",56,N],[11,"mul_assign","","",56,N],[11,"mul_assign","","",56,N],[11,"sub_assign","","",56,N],[11,"sub_assign","","",56,N],[11,"sub_assign","","",53,N],[11,"sub_assign","lumol::sys","Disables all flags enabled in the set.",51,N],[11,"sub_assign","lumol::types","",54,N],[11,"sub_assign","","",53,N],[11,"sub_assign","","",53,N],[11,"sub_assign","","",56,N],[11,"partial_cmp","lumol::sys","",51,[[["self"],["bonddistances"]],["option",["ordering"]]]],[11,"lt","","",51,[[["self"],["bonddistances"]],["bool"]]],[11,"le","","",51,[[["self"],["bonddistances"]],["bool"]]],[11,"gt","","",51,[[["self"],["bonddistances"]],["bool"]]],[11,"ge","","",51,[[["self"],["bonddistances"]],["bool"]]],[11,"partial_cmp","","",84,[[["self"],["moleculehash"]],["option",["ordering"]]]],[11,"lt","","",84,[[["self"],["moleculehash"]],["bool"]]],[11,"le","","",84,[[["self"],["moleculehash"]],["bool"]]],[11,"gt","","",84,[[["self"],["moleculehash"]],["bool"]]],[11,"ge","","",84,[[["self"],["moleculehash"]],["bool"]]],[11,"partial_cmp","lumol::types","",53,[[["self"],["vector3d"]],["option",["ordering"]]]],[11,"lt","","",53,[[["self"],["vector3d"]],["bool"]]],[11,"le","","",53,[[["self"],["vector3d"]],["bool"]]],[11,"gt","","",53,[[["self"],["vector3d"]],["bool"]]],[11,"ge","","",53,[[["self"],["vector3d"]],["bool"]]],[11,"partial_cmp","lumol::sys","",22,[[["self"],["particlekind"]],["option",["ordering"]]]],[11,"lt","","",22,[[["self"],["particlekind"]],["bool"]]],[11,"le","","",22,[[["self"],["particlekind"]],["bool"]]],[11,"gt","","",22,[[["self"],["particlekind"]],["bool"]]],[11,"ge","","",22,[[["self"],["particlekind"]],["bool"]]],[11,"partial_cmp","","",89,[[["self"],["bond"]],["option",["ordering"]]]],[11,"lt","","",89,[[["self"],["bond"]],["bool"]]],[11,"le","","",89,[[["self"],["bond"]],["bool"]]],[11,"gt","","",89,[[["self"],["bond"]],["bool"]]],[11,"ge","","",89,[[["self"],["bond"]],["bool"]]],[11,"initialize","lumol::units","",73,N],[11,"bitand_assign","lumol::sys","Disables all flags disabled in the set.",51,N],[11,"fmt","","",51,[[["self"],["formatter"]],["result",["error"]]]],[11,"hash","","",22,N],[11,"hash","","",90,N],[11,"hash","","",87,N],[11,"hash","","",51,N],[11,"hash","","",89,N],[11,"tail_energy","lumol::energy","",11,[[["self"],["f64"]],["f64"]]],[11,"tail_virial","","",11,[[["self"],["f64"]],["f64"]]],[11,"tail_energy","","",80,[[["self"],["f64"]],["f64"]]],[11,"tail_virial","","",80,[[["self"],["f64"]],["f64"]]],[11,"tail_energy","","",83,[[["self"],["f64"]],["f64"]]],[11,"tail_virial","","",83,[[["self"],["f64"]],["f64"]]],[11,"tail_energy","","",4,[[["self"],["f64"]],["f64"]]],[11,"tail_virial","","",4,[[["self"],["f64"]],["f64"]]],[11,"tail_energy","","",85,[[["self"],["f64"]],["f64"]]],[11,"tail_virial","","",85,[[["self"],["f64"]],["f64"]]],[11,"tail_energy","","",81,[[["self"],["f64"]],["f64"]]],[11,"tail_virial","","",81,[[["self"],["f64"]],["f64"]]],[11,"tail_energy","","",7,[[["self"],["f64"]],["f64"]]],[11,"tail_virial","","",7,[[["self"],["f64"]],["f64"]]],[11,"tail_energy","","",16,[[["self"],["f64"]],["f64"]]],[11,"tail_virial","","",16,[[["self"],["f64"]],["f64"]]],[11,"tail_energy","","",10,[[["self"],["f64"]],["f64"]]],[11,"tail_virial","","",10,[[["self"],["f64"]],["f64"]]],[11,"energy","","",81,[[["self"],["f64"]],["f64"]]],[11,"force","","",81,[[["self"],["f64"]],["f64"]]],[11,"energy","","",83,[[["self"],["f64"]],["f64"]]],[11,"force","","",83,[[["self"],["f64"]],["f64"]]],[11,"energy","","",85,[[["self"],["f64"]],["f64"]]],[11,"force","","",85,[[["self"],["f64"]],["f64"]]],[11,"energy","","",11,[[["self"],["f64"]],["f64"]]],[11,"force","","",11,[[["self"],["f64"]],["f64"]]],[11,"energy","","",16,[[["self"],["f64"]],["f64"]]],[11,"force","","",16,[[["self"],["f64"]],["f64"]]],[11,"energy","","",7,[[["self"],["f64"]],["f64"]]],[11,"force","","",7,[[["self"],["f64"]],["f64"]]],[11,"energy","","",10,[[["self"],["f64"]],["f64"]]],[11,"force","","",10,[[["self"],["f64"]],["f64"]]],[11,"energy","","",4,[[["self"],["f64"]],["f64"]]],[11,"force","","",4,[[["self"],["f64"]],["f64"]]],[11,"energy","","",8,[[["self"],["f64"]],["f64"]]],[11,"force","","",8,[[["self"],["f64"]],["f64"]]],[11,"energy","","",79,[[["self"],["f64"]],["f64"]]],[11,"force","","",79,[[["self"],["f64"]],["f64"]]],[11,"bitxor","lumol::types","",53,[[["self"],["vector3d"]],["vector3d"]]],[11,"bitxor","","",53,[[["self"],["vector3d"]],["vector3d"]]],[11,"bitxor","lumol::sys","Returns the left flags, but with all the right flags toggled.",51,[[["self"],["bonddistances"]],["bonddistances"]]],[11,"bitxor","lumol::types","",53,[[["self"],["vector3d"]],["vector3d"]]],[11,"from","","",56,N],[11,"from","lumol::sys","",52,[[["error"]],["error"]]],[11,"from","lumol::units","",0,[[["parsefloaterror"]],["parseerror"]]],[11,"from","lumol::types","",53,N],[11,"from","lumol::units","",0,[[["parseinterror"]],["parseerror"]]],[11,"not","lumol::sys","Returns the complement of this set of flags.",51,[[["self"]],["bonddistances"]]],[11,"eq","lumol::types","",54,[[["self"],["complex"]],["bool"]]],[11,"ne","","",54,[[["self"],["complex"]],["bool"]]],[11,"eq","","",53,[[["self"],["vector3d"]],["bool"]]],[11,"ne","","",53,[[["self"],["vector3d"]],["bool"]]],[11,"eq","lumol::sys","",22,[[["self"],["particlekind"]],["bool"]]],[11,"ne","","",22,[[["self"],["particlekind"]],["bool"]]],[11,"eq","","",84,[[["self"],["moleculehash"]],["bool"]]],[11,"ne","","",84,[[["self"],["moleculehash"]],["bool"]]],[11,"eq","lumol::types","",57,[[["self"],["array3"]],["bool"]]],[11,"ne","","",57,[[["self"],["array3"]],["bool"]]],[11,"eq","lumol::sys","",89,[[["self"],["bond"]],["bool"]]],[11,"ne","","",89,[[["self"],["bond"]],["bool"]]],[11,"eq","lumol::energy","",13,[[["self"],["pairrestriction"]],["bool"]]],[11,"ne","","",13,[[["self"],["pairrestriction"]],["bool"]]],[11,"eq","lumol::sys","",86,[[["self"],["unitcell"]],["bool"]]],[11,"ne","","",86,[[["self"],["unitcell"]],["bool"]]],[11,"eq","lumol::energy","",5,[[["self"],["bondpath"]],["bool"]]],[11,"eq","lumol::types","",55,[[["self"],["array2"]],["bool"]]],[11,"ne","","",55,[[["self"],["array2"]],["bool"]]],[11,"eq","lumol::sys","",90,[[["self"],["angle"]],["bool"]]],[11,"ne","","",90,[[["self"],["angle"]],["bool"]]],[11,"eq","","",87,[[["self"],["dihedral"]],["bool"]]],[11,"ne","","",87,[[["self"],["dihedral"]],["bool"]]],[11,"eq","","",82,[[["self"],["composition"]],["bool"]]],[11,"ne","","",82,[[["self"],["composition"]],["bool"]]],[11,"eq","lumol::types","",56,[[["self"],["matrix3"]],["bool"]]],[11,"ne","","",56,[[["self"],["matrix3"]],["bool"]]],[11,"eq","lumol::sys","",21,[[["self"],["cellshape"]],["bool"]]],[11,"eq","","",51,[[["self"],["bonddistances"]],["bool"]]],[11,"ne","","",51,[[["self"],["bonddistances"]],["bool"]]],[11,"eq","","",29,[[["self"],["degreesoffreedom"]],["bool"]]],[11,"ne","","",29,[[["self"],["degreesoffreedom"]],["bool"]]],[11,"zero","lumol::types","",56,[[],["matrix3"]]],[11,"is_zero","","",56,[[["self"]],["bool"]]],[11,"zero","","",54,[[],["complex"]]],[11,"is_zero","","",54,[[["self"]],["bool"]]],[11,"zero","","",53,[[],["vector3d"]]],[11,"is_zero","","",53,[[["self"]],["bool"]]],[11,"fmt","lumol::input","",50,[[["self"],["formatter"]],["result",["error"]]]],[11,"from_toml","lumol::energy","",74,[[["btreemap"],["configuration"]],["result",["ewald","error"]]]],[11,"from_toml","lumol::sim::mc","",91,[[["btreemap"],["pathbuf"]],["result",["resize","error"]]]],[11,"from_toml","lumol::sim::md","",92,[[["btreemap"],["f64"]],["result",["velocityverlet","error"]]]],[11,"from_toml","lumol::sim::mc","",93,[[["btreemap"],["pathbuf"]],["result",["rotate","error"]]]],[11,"from_toml","","",94,[[["btreemap"],["pathbuf"]],["result",["montecarlo","error"]]]],[11,"from_toml","lumol::sim::md","",95,[[["btreemap"],["f64"]],["result",["leapfrog","error"]]]],[11,"from_toml","lumol::energy","",80,[[["btreemap"],["box",["pairpotential"]]],["result",["tablecomputation","error"]]]],[11,"from_toml","lumol::sim::md","",96,[[["btreemap"],["f64"]],["result",["anisoberendsenbarostat","error"]]]],[11,"from_toml","lumol::sim::mc","",97,[[["btreemap"],["pathbuf"]],["result",["translate","error"]]]],[11,"from_toml","lumol::sim::md","",98,[[["btreemap"],["f64"]],["result",["verlet","error"]]]],[11,"from_toml","","",99,[[["btreemap"],["f64"]],["result",["berendsenbarostat","error"]]]],[11,"description","lumol::input","",50,[[["self"]],["str"]]],[11,"cause","","",50,[[["self"]],["option",["error"]]]],[11,"from_toml","lumol::sim::output","",100,[[["btreemap"]],["result",["celloutput","error"]]]],[11,"from_toml","lumol::sim::min","",101,[[["btreemap"]],["result",["minimization","error"]]]],[11,"from_toml","lumol::energy","",79,[[["btreemap"]],["result",["cosineharmonic","error"]]]],[11,"from_toml","","",7,[[["btreemap"]],["result",["bornmayerhuggins","error"]]]],[11,"from_toml","","",8,[[["btreemap"]],["result",["torsion","error"]]]],[11,"from_toml","","",11,[[["btreemap"]],["result",["lennardjones","error"]]]],[11,"from_toml","","",83,[[["btreemap"]],["result",["gaussian","error"]]]],[11,"from_toml","","",81,[[["btreemap"]],["result",["mie","error"]]]],[11,"from_toml","","",85,[[["btreemap"]],["result",["nullpotential","error"]]]],[11,"from_toml","lumol::sim::min","",102,[[["btreemap"]],["result",["steepestdescent","error"]]]],[11,"from_toml","lumol::energy","",4,[[["btreemap"]],["result",["buckingham","error"]]]],[11,"from_toml","lumol::sim::output","",103,[[["btreemap"]],["result",["customoutput","error"]]]],[11,"from_toml","lumol::sim::md","",104,[[["btreemap"]],["result",["rescalethermostat","error"]]]],[11,"from_toml","lumol::energy","",10,[[["btreemap"]],["result",["morse","error"]]]],[11,"from_toml","lumol::sim::md","",105,[[["btreemap"]],["result",["berendsenthermostat","error"]]]],[11,"from_toml","lumol::sim::output","",106,[[["btreemap"]],["result",["forcesoutput","error"]]]],[11,"from_toml","lumol::sim::md","",107,[[["btreemap"]],["result",["moleculardynamics","error"]]]],[11,"from_toml","lumol::sim::output","",108,[[["btreemap"]],["result",["energyoutput","error"]]]],[11,"from_toml","lumol::sim::min","",42,[[["btreemap"]],["result",["tolerance","error"]]]],[11,"from_toml","lumol::sim::output","",109,[[["btreemap"]],["result",["trajectoryoutput","error"]]]],[11,"from_toml","lumol::energy","",76,[[["btreemap"]],["result",["wolf","error"]]]],[11,"from_toml","lumol::sim::output","",110,[[["btreemap"]],["result",["propertiesoutput","error"]]]],[11,"from_toml","lumol::energy","",16,[[["btreemap"]],["result",["harmonic","error"]]]],[11,"from_toml","lumol::sim::output","",111,[[["btreemap"]],["result",["stressoutput","error"]]]],[11,"from","lumol::input","",50,[[["parseerror"]],["error"]]],[11,"from","","",50,[[["str"]],["error"]]],[11,"from","","",50,N],[11,"from","","",50,[[["string"]],["error"]]],[11,"from","","",50,[[["error"]],["error"]]],[11,"from","","",50,N],[11,"fmt","","",50,[[["self"],["formatter"]],["result",["error"]]]],[11,"clone","lumol::sim","",43,[[["self"]],["temperaturestrategy"]]],[11,"clone","lumol::sim::mc","",38,[[["self"]],["mcdegreeoffreedom"]]],[11,"init","lumol::sim","",112,N],[11,"seed","","",112,N],[11,"init","","",113,N],[11,"seed","","",113,N],[11,"fmt","lumol::sim::mc","",38,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::sim","",43,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","lumol::sim::output","",35,[[["self"],["formatter"]],["result",["error"]]]],[11,"description","","",35,[[["self"]],["str"]]],[11,"cause","","",35,[[["self"]],["option",["error"]]]],[11,"degrees_of_freedom","lumol::sim::min","",102,[[["self"],["system"]],["degreesoffreedom"]]],[11,"minimize","","",102,[[["self"],["system"]],["tolerance"]]],[11,"temperature_strategy","","",101,[[["self"]],["temperaturestrategy"]]],[11,"degrees_of_freedom","","",101,[[["self"],["system"]],["degreesoffreedom"]]],[11,"setup","","",101,N],[11,"propagate","","",101,N],[11,"temperature_strategy","lumol::sim::mc","",94,[[["self"]],["temperaturestrategy"]]],[11,"degrees_of_freedom","","",94,[[["self"],["system"]],["degreesoffreedom"]]],[11,"setup","","",94,N],[11,"propagate","","",94,N],[11,"finish","","Print some informations about moves to screen",94,N],[11,"temperature_strategy","lumol::sim::md","",107,[[["self"]],["temperaturestrategy"]]],[11,"degrees_of_freedom","","",107,[[["self"],["system"]],["degreesoffreedom"]]],[11,"setup","","",107,N],[11,"propagate","","",107,N],[11,"finish","","",107,N],[11,"control","","",114,N],[11,"control","","",115,N],[11,"control","","",104,N],[11,"control","","",105,N],[11,"control","","",116,N],[11,"describe","lumol::sim::mc","",97,[[["self"]],["str"]]],[11,"degrees_of_freedom","","",97,[[["self"]],["mcdegreeoffreedom"]]],[11,"setup","","",97,N],[11,"prepare","","",97,[[["self"],["system"],["rngcore"]],["bool"]]],[11,"cost","","",97,[[["self"],["system"],["f64"],["energycache"]],["f64"]]],[11,"apply","","",97,N],[11,"restore","","",97,N],[11,"update_amplitude","","",97,N],[11,"describe","","",91,[[["self"]],["str"]]],[11,"degrees_of_freedom","","",91,[[["self"]],["mcdegreeoffreedom"]]],[11,"setup","","",91,N],[11,"prepare","","",91,[[["self"],["system"],["rngcore"]],["bool"]]],[11,"cost","","",91,[[["self"],["system"],["f64"],["energycache"]],["f64"]]],[11,"apply","","",91,N],[11,"restore","","",91,N],[11,"update_amplitude","","",91,N],[11,"describe","","",93,[[["self"]],["str"]]],[11,"degrees_of_freedom","","",93,[[["self"]],["mcdegreeoffreedom"]]],[11,"setup","","",93,N],[11,"prepare","","",93,[[["self"],["system"],["rngcore"]],["bool"]]],[11,"cost","","",93,[[["self"],["system"],["f64"],["energycache"]],["f64"]]],[11,"apply","","",93,N],[11,"restore","","",93,N],[11,"update_amplitude","","",93,N],[11,"setup","lumol::sim::output","",106,N],[11,"write","","",106,N],[11,"setup","","",111,N],[11,"write","","",111,N],[11,"setup","","",108,N],[11,"write","","",108,N],[11,"write","","",109,N],[11,"setup","","",100,N],[11,"write","","",100,N],[11,"setup","","",103,N],[11,"write","","",103,N],[11,"setup","","",110,N],[11,"write","","",110,N],[11,"setup","lumol::sim::md","",95,N],[11,"integrate","","",95,N],[11,"setup","","",92,N],[11,"integrate","","",92,N],[11,"setup","","",99,N],[11,"integrate","","",99,N],[11,"setup","","",98,N],[11,"integrate","","",98,N],[11,"setup","","",96,N],[11,"integrate","","",96,N],[11,"from","lumol::sim::output","",35,[[["error"]],["customoutputerror"]]],[11,"from","","",35,[[["error"]],["customoutputerror"]]],[11,"from","","",35,[[["string"]],["customoutputerror"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result",["error"]]]],[11,"eq","lumol::sim","",43,[[["self"],["temperaturestrategy"]],["bool"]]],[11,"ne","","",43,[[["self"],["temperaturestrategy"]],["bool"]]],[11,"eq","lumol::sim::mc","",38,[[["self"],["mcdegreeoffreedom"]],["bool"]]],[11,"ne","","",38,[[["self"],["mcdegreeoffreedom"]],["bool"]]],[11,"polar","lumol::types","Create a new `Complex` from a norm `r` and a phase `phi` in radians.",54,[[["f64"],["f64"]],["complex"]]],[11,"cartesian","","Create a complex from Cartesian coordinates",54,[[["f64"],["f64"]],["complex"]]],[11,"zero","","Create a new `Complex` with both cartesian coordinate set to 0.",54,[[],["complex"]]],[11,"real","","Get the real part of the complex # Examples `# use lumol_core::types::Complex; let z = Complex::cartesian(3.0, -2.0); assert_eq!(z.real(), 3.0);`",54,[[["self"]],["f64"]]],[11,"imag","","Get the imaginary part of the complex # Examples `# use lumol_core::types::Complex; let z = Complex::cartesian(3.0, -2.0); assert_eq!(z.imag(), -2.0);`",54,[[["self"]],["f64"]]],[11,"phase","","Get the phase of the complex in the [-π, π) interval # Examples `# use lumol_core::types::Complex; let z = Complex::polar(2.0, 0.3); assert_eq!(z.phase(), 0.3);`",54,[[["self"]],["f64"]]],[11,"norm","","Get the norm of the complex # Examples ``` # use lumol_core::types::Complex; # use std::f64; let z = Complex::polar(2.0, 0.3); assert_eq!(z.norm(), 2.0);",54,[[["self"]],["f64"]]],[11,"norm2","","Get the square of the norm if this complex # Examples `# use lumol_core::types::Complex; let z = Complex::cartesian(2.0, 1.0); assert_eq!(z.norm2(), 5.0);`",54,[[["self"]],["f64"]]],[11,"conj","","Get the conjugate of the complex # Examples `# use lumol_core::types::Complex; let z = Complex::cartesian(2.0, 1.0); assert_eq!(z.conj(), Complex::cartesian(2.0, -1.0));`",54,[[["self"]],["complex"]]],[11,"zeros","","Create a new `Array2` of the specified `size` filled with the `Zero::zero` return value.",55,N],[11,"resize_if_different","","Resize the array if the current size is not `size`, and fill the new array with zeros.",55,N],[11,"default","","Create a new `Array2` of the specified `size` filled with the `Default::default` return value.",55,N],[11,"new","","Create a new `Matrix3` specifying all its components # Examples `# use lumol_core::types::Matrix3; let matrix = Matrix3::new([ [0.0, 0.0, 3.0], [0.0, 1.0, 5.6], [0.0, 0.0, 7.0], ]); assert_eq!(matrix[0][2], 3.0);`",56,N],[11,"zero","","Create a new `Matrix3` with components set to `0`",56,[[],["matrix3"]]],[11,"one","","Create a new `Vector3D` with components all components set to `0`, except the diagonal components set to 1.",56,[[],["matrix3"]]],[11,"rotation","","Returns rotation matrix given a rotation angle and an axis.",56,[[["vector3d"],["f64"]],["matrix3"]]],[11,"trace","","Compute the trace of the matrix # Examples `# use lumol_core::types::Matrix3; let matrix = Matrix3::new([ [0.0, 0.0, 3.0], [0.0, 1.0, 5.6], [0.0, 0.0, 7.0] ]); assert_eq!(matrix.trace(), 8.0);`",56,[[["self"]],["f64"]]],[11,"inverse","","Computes the inverse of a matrix",56,[[["self"]],["matrix3"]]],[11,"determinant","","Computes the [determinant][Wiki] of a matrix",56,[[["self"]],["f64"]]],[11,"transposed","","Transpose this matrix into a new matrix",56,[[["self"]],["matrix3"]]],[11,"norm","","Compute the (Frobenius) norm of the matrix",56,[[["self"]],["f64"]]],[11,"new","","Create a new `Vector3D` with components `x`, `y`, `z`",53,[[["f64"],["f64"],["f64"]],["vector3d"]]],[11,"zero","","Create a new `Vector3D` with components `0`, `0`, `0`",53,[[],["vector3d"]]],[11,"norm2","","Return the squared euclidean norm of a `Vector3D`",53,[[["self"]],["f64"]]],[11,"norm","","Return the euclidean norm of a `Vector3D` # Examples `# use lumol_core::types::Vector3D; # use std::f64; let vec = Vector3D::new(1.0, 0.0, -4.0); assert_eq!(vec.norm(), f64::sqrt(17.0));`",53,[[["self"]],["f64"]]],[11,"normalized","","Normalize a `Vector3D`. # Examples `# use lumol_core::types::Vector3D; let vec = Vector3D::new(1.0, 0.0, -4.0); let n = vec.normalized(); assert_eq!(n.norm(), 1.0);`",53,[[["self"]],["vector3d"]]],[11,"tensorial","","Tensorial product between vectors. The tensorial product between the vectors `a` and `b` creates a `Matrix3` with component (i, j) equals to `a[i] * b[j]`.",53,[[["self"],["vector3d"]],["matrix3"]]],[11,"min","","Get the minimal value in this vector, using `std::f64::min` for comparison.",53,[[["self"]],["f64"]]],[11,"max","","Get the maximal value in this vector, using `std::f64::max` for comparison.",53,[[["self"]],["f64"]]],[11,"zeros","","Create a new `Array3` of the specified `size` filled with the `Zero::zero` return value.",57,N],[11,"resize_if_different","","Resize the array if the current size is not `size`, and fill the new array with zeros.",57,N],[11,"default","","Create a new `Array3` of the specified `size` filled with the `Default::default` return value. `Default::default` return value.",57,N],[11,"new","lumol::energy","Create a new `CosineHarmonic` potentials, with elastic constant of `k` and equilibrium value of `x0`",79,[[["f64"],["f64"]],["cosineharmonic"]]],[11,"new","","Return Mie potential.",81,[[["f64"],["f64"],["f64"],["f64"]],["mie"]]],[11,"new","","Create an Ewald summation using the given `cutoff` radius in real space, and `kmax` points in k-space (Fourier space). If `alpha` is None, then the default value of `π / cutoff` is used.",74,[[["f64"],["usize"],["i"]],["ewald"]]],[11,"with_accuracy","","Create an Ewald solver with the given real space `cutoff`, setting `alpha` and `kmax` to ensure that the energy is computed with the specified relative `accuracy`. The optimal parameter depends on the exact `configuration` used: both the total number of charges, and the unit cell.",74,[[["f64"],["f64"],["configuration"]],["ewald"]]],[11,"new","","Create a new `PairInteraction` for the given `potential` and using the given `cutoff` distance.",88,[[["box",["pairpotential"]],["f64"]],["pairinteraction"]]],[11,"shifted","","Create a new `PairInteraction` with the given `cutoff`, using shifted computation of the energy.",88,[[["box",["pairpotential"]],["f64"]],["pairinteraction"]]],[11,"enable_tail_corrections","","Enable the use of tail corrections for energy and virial contribution of this pair interaction.",88,N],[11,"restriction","","Get the associated pair restriction. The default is to have no pair restriction.",88,[[["self"]],["pairrestriction"]]],[11,"set_restriction","","Set the pair restriction associated with this interaction.",88,N],[11,"cutoff","","Return the cutoff radius",88,[[["self"]],["f64"]]],[11,"energy","","Get the energy for this pair interaction at the distance `r`.",88,[[["self"],["f64"]],["f64"]]],[11,"force","","Get the norm of the force for this pair interaction at the distance `r`.",88,[[["self"],["f64"]],["f64"]]],[11,"virial","","Get the virial contribution for this pair interaction at the distance `r`.",88,[[["self"],["vector3d"]],["matrix3"]]],[11,"tail_energy","","Get the tail correction to the energy for this pair interaction",88,[[["self"]],["f64"]]],[11,"tail_virial","","Get the tail correction to the virial for this pair interaction",88,[[["self"]],["matrix3"]]],[11,"new","","Create a new `TableComputation` for `potential`, with `size` points and a maximum value of `max`.",80,[[["box",["pairpotential"]],["usize"],["f64"]],["tablecomputation"]]],[11,"new","","Create a new Wolf summation, using a real-space cutoff of `cutoff`.",76,[[["f64"]],["wolf"]]],[11,"new","","Create a new `Gaussian` potential with a depth of `a` and a width of `b`",83,[[["f64"],["f64"]],["gaussian"]]],[11,"information","","Get the restriction at the given [bond `path`][path].",13,[[["self"],["bondpath"]],["restrictioninfo"]]],[11,"new","","Wrap `ewald` in a thread-safe structure.",75,[[["ewald"]],["sharedewald"]]],[11,"len","lumol::sys","Similar to `[Particle] ::len()`,  the length of all fields should be the same.",20,[[["self"]],["usize"]]],[11,"is_empty","","Similar to `[Particle] ::is_empty()`,  the length of all fields should be the same.",20,[[["self"]],["bool"]]],[11,"first","","Similar to `[Particle] ::first()`.",20,[[["self"]],["option",["particleref"]]]],[11,"split_first","","Similar to `[Particle] ::split_first()`.",20,[[["self"]],["option"]]],[11,"last","","Similar to `[Particle] ::last()`.",20,[[["self"]],["option",["particleref"]]]],[11,"split_last","","Similar to `[Particle] ::split_last()`.",20,[[["self"]],["option"]]],[11,"split_at","","Similar to `[Particle] ::split_at()`.",20,N],[11,"get","","Similar to `[Particle] ::get()`.",20,[[["self"],["usize"]],["option",["particleref"]]]],[11,"get_unchecked","","Similar to `[Particle] ::get_unchecked()`.",20,[[["self"],["usize"]],["particleref"]]],[11,"as_ptr","","Similar to `[Particle] ::as_ptr()`.",20,[[["self"]],["particleptr"]]],[11,"from_raw_parts","","Similar to `std::slice::from_raw_parts()`.",20,[[["particleptr"],["usize"]],["particleslice"]]],[11,"to_vec","","Similar to `[Particle] ::to_vec()`.",20,[[["self"]],["particlevec"]]],[11,"iter","","Get an iterator over the `ParticleRef`  in this slice.",20,[[["self"]],["iter"]]],[11,"new","","Create a new empty composition",82,[[],["composition"]]],[11,"add_particle","","Add a particle with the given `kind` to the internal counter",82,N],[11,"remove_particle","","Remove a particle with the given `kind` to the internal counter",82,N],[11,"particles","","Get the number of particles with a given kind",82,[[["self"],["particlekind"]],["usize"]]],[11,"all_particles","","Get an iterator over the particles kind and count",82,N],[11,"add_molecule","","Add a molecule with the given `moltype` to the internal counter",82,N],[11,"remove_molecule","","Add a molecule with the given `moltype` to the internal counter",82,N],[11,"molecules","","Get the number of particles with the given `hash`",82,[[["self"],["moleculehash"]],["usize"]]],[11,"all_molecules","","Get an iterator over the molecules hashes and count",82,N],[11,"new","","Create a new `EnergyEvaluator` acting on the given `system`.",117,[[["system"]],["energyevaluator"]]],[11,"pair","","Compute the energy associated with the pair of particles `i, j` at distance `r`",117,[[["self"],["bondpath"],["f64"],["usize"],["usize"]],["f64"]]],[11,"pairs","","Compute the energy of all the pairs in the system",117,[[["self"]],["f64"]]],[11,"pairs_tail","","Compute the energy due to long range corrections for the pairs",117,[[["self"]],["f64"]]],[11,"bond","","Compute the energy associated with the bonded particles `i, j` at distance `r`",117,[[["self"],["f64"],["usize"],["usize"]],["f64"]]],[11,"bonds","","Compute the energy of all the bonds in the system",117,[[["self"]],["f64"]]],[11,"angle","","Compute the energy associated with the angle `i, j, k` at angle `theta`",117,[[["self"],["f64"],["usize"],["usize"],["usize"]],["f64"]]],[11,"angles","","Compute the energy of all the angles in the system",117,[[["self"]],["f64"]]],[11,"dihedral","","Compute the energy associated with the dihedral angle `i, j, k, m` at angle `phi`",117,[[["self"],["f64"],["usize"],["usize"],["usize"],["usize"]],["f64"]]],[11,"dihedrals","","Compute the energy of all the dihedral angles in the system",117,[[["self"]],["f64"]]],[11,"coulomb","","Compute the energy of the electrostatic interactions",117,[[["self"]],["f64"]]],[11,"global","","Compute the energy of the global potentials",117,[[["self"]],["f64"]]],[11,"invalid","","Get an invalid value (`u32::max_value()`) to use as a marker",22,[[],["particlekind"]]],[11,"new","","Create a new `Particle` from a `name`, setting the mass to the atomic mass if the `name` can be found in the periodic table. The charge, position, and velocity are set to 0.",23,[[["s"]],["particle"]]],[11,"with_position","","Create a new `Particle` from a `name` and a `position`, setting the mass to the atomic mass if the `name` can be found in the periodic table. The charge and velocity are set to 0.",23,[[["s"],["vector3d"]],["particle"]]],[11,"as_ref","","Create a `ParticleRef`  from a borrowed `Particle`  .",23,[[["self"]],["particleref"]]],[11,"as_mut","","Create a `ParticleRefMut`  from a mutably borrowed `Particle`  .",23,[[["self"]],["particlerefmut"]]],[11,"as_ptr","","Convert a `ParticlePtrMut`  to a `ParticlePtr`  ; i.e. do a `*mut T as *const T` transformation",24,[[["self"]],["particleptr"]]],[11,"is_null","","Similar to `*mut T::is_null()`.",24,[[["self"]],["bool"]]],[11,"as_ref","","Similar to `*mut T::as_ref()`, with the same safety caveats.",24,[[["self"]],["option",["particleref"]]]],[11,"as_mut","","Similar to `*mut T::as_mut()`, with the same safety caveats.",24,[[["self"]],["option",["particlerefmut"]]]],[11,"offset","","Similar to `*mut T::offset()`, with the same safety caveats.",24,[[["self"],["isize"]],["particleptrmut"]]],[11,"wrapping_offset","","Similar to `*mut T::wrapping_offset()`",24,[[["self"],["isize"]],["particleptrmut"]]],[11,"add","","Similar to `*mut T::add()`, with the same safety caveats.",24,[[["self"],["usize"]],["particleptrmut"]]],[11,"sub","","Similar to `*mut T::sub()`, with the same safety caveats.",24,[[["self"],["usize"]],["particleptrmut"]]],[11,"wrapping_add","","Similar to `*mut T::wrapping_add()`, with the same safety caveats.",24,[[["self"],["usize"]],["particleptrmut"]]],[11,"wrapping_sub","","Similar to `*mut T::wrapping_sub()`, with the same safety caveats.",24,[[["self"],["usize"]],["particleptrmut"]]],[11,"read","","Similar to `*mut T::read()`, with the same safety caveats.",24,[[["self"]],["particle"]]],[11,"read_volatile","","Similar to `*mut T::read_volatile()`, with the same safety caveats.",24,[[["self"]],["particle"]]],[11,"read_unaligned","","Similar to `*mut T::read_unaligned()`, with the same safety caveats.",24,[[["self"]],["particle"]]],[11,"write","","Similar to `*mut T::write()`, with the same safety caveats.",24,N],[11,"write_volatile","","Similar to `*mut T::write_volatile()`, with the same safety caveats.",24,N],[11,"write_unaligned","","Similar to `*mut T::write_unaligned()`, with the same safety caveats.",24,N],[11,"new","","Create a new Dihedral between the particles at indexes `first`, `second`, `third` and `fourth`",87,[[["usize"],["usize"],["usize"],["usize"]],["dihedral"]]],[11,"i","","Get the first particle in the dihedral angle",87,[[["self"]],["usize"]]],[11,"j","","Get the second particle in the dihedral angle",87,[[["self"]],["usize"]]],[11,"k","","Get the third particle in the dihedral angle",87,[[["self"]],["usize"]]],[11,"m","","Get the fourth particle in the dihedral angle",87,[[["self"]],["usize"]]],[11,"new","","Create a new Bond between the particles at indexes `first` and `second`",89,[[["usize"],["usize"]],["bond"]]],[11,"i","","Get the first particle in the bond",89,[[["self"]],["usize"]]],[11,"j","","Get the second particle in the bond",89,[[["self"]],["usize"]]],[11,"infinite","","Create an infinite unit cell",86,[[],["unitcell"]]],[11,"ortho","","Create an orthorhombic unit cell, with side lengths `a, b, c`.",86,[[["f64"],["f64"],["f64"]],["unitcell"]]],[11,"cubic","","Create a cubic unit cell, with side lengths `length, length, length`.",86,[[["f64"]],["unitcell"]]],[11,"triclinic","","Create a triclinic unit cell, with side lengths `a, b, c` and angles `alpha, beta, gamma`.",86,[[["f64"],["f64"],["f64"],["f64"],["f64"],["f64"]],["unitcell"]]],[11,"shape","","Get the cell shape",86,[[["self"]],["cellshape"]]],[11,"is_infinite","","Check if this unit cell is infinite, i.e. if it does not have periodic boundary conditions.",86,[[["self"]],["bool"]]],[11,"a","","Get the first length of the cell (i.e. the norm of the first vector of the cell)",86,[[["self"]],["f64"]]],[11,"b","","Get the second length of the cell (i.e. the norm of the second vector of the cell)",86,[[["self"]],["f64"]]],[11,"c","","Get the third length of the cell (i.e. the norm of the third vector of the cell)",86,[[["self"]],["f64"]]],[11,"lengths","","Get the distances between faces of the unit cell",86,[[["self"]],["vector3d"]]],[11,"alpha","","Get the first angle of the cell",86,[[["self"]],["f64"]]],[11,"beta","","Get the second angle of the cell",86,[[["self"]],["f64"]]],[11,"gamma","","Get the third angle of the cell",86,[[["self"]],["f64"]]],[11,"volume","","Get the volume of the cell",86,[[["self"]],["f64"]]],[11,"scale_mut","","Scale this unit cell in-place by multiplying the cell matrix by `factor`.",86,N],[11,"scale","","Scale this unit cell by multiplying the cell matrix by `s`, and return a new scaled unit cell",86,[[["self"],["matrix3"]],["unitcell"]]],[11,"k_vector","","Get the reciprocal vector with the given `index`. This vector is null for infinite cells.",86,N],[11,"matrix","","Get the matricial representation of the unit cell",86,[[["self"]],["matrix3"]]],[11,"wrap_vector","","Wrap a vector in the unit cell, obeying the periodic boundary conditions. For a cubic cell of side length `L`, this produce a vector with all components in `[0, L)`.",86,N],[11,"vector_image","","Find the image of a vector in the unit cell, obeying the periodic boundary conditions. For a cubic cell of side length `L`, this produce a vector with all components in `[-L/2, L/2)`.",86,N],[11,"fractional","","Get the fractional representation of the `vector` in this cell",86,[[["self"],["vector3d"]],["vector3d"]]],[11,"cartesian","","Get the Cartesian representation of the `fractional` vector in this cell",86,[[["self"],["vector3d"]],["vector3d"]]],[11,"distance","","Periodic boundary conditions distance between the point `u` and the point `v`",86,[[["self"],["vector3d"],["vector3d"]],["f64"]]],[11,"angle","","Get the angle formed by the points at `r1`, `r2` and `r3` using periodic boundary conditions.",86,[[["self"],["vector3d"],["vector3d"],["vector3d"]],["f64"]]],[11,"angle_and_derivatives","","Get the angle formed by the points at `r1`, `r2` and `r3` using periodic boundary conditions and its derivatives.",86,N],[11,"dihedral","","Get the dihedral angle formed by the points at `r1`, `r2`, `r3`, and `r4` using periodic boundary conditions.",86,[[["self"],["vector3d"],["vector3d"],["vector3d"],["vector3d"]],["f64"]]],[11,"dihedral_and_derivatives","","Get the dihedral angle and and its derivatives defined by the points at `r1`, `r2`, `r3`, and `r4` using periodic boundary conditions.",86,N],[11,"new","","Create a new `Molecule` containing a single `particle`",72,[[["particle"]],["molecule"]]],[11,"as_ref","","Borrow `self` as a `MoleculeRef`.",72,[[["self"]],["moleculeref"]]],[11,"as_mut","","Mutablely borrow `self` as a `MoleculeRefMut`.",72,[[["self"]],["moleculerefmut"]]],[11,"particles","","Get access to the particles in this molecule",72,[[["self"]],["particleslice"]]],[11,"particles_mut","","Get mutable access to the particles in this molecule",72,[[["self"]],["particleslicemut"]]],[11,"add_particle_bonded_to","","Add a new `particle` in this molecule, bonded to an `other` particle in the molecule.",72,N],[11,"add_bond","","Add bond between particles at indexes `i` and `j` in this molecule.",72,N],[11,"center_of_mass","","Return the center-of-mass of a molecule",72,[[["self"]],["vector3d"]]],[11,"hash","","Get a hash of this molecule. This is a hash of the particles names (in order), and the set of bonds in the molecule. This means that two molecules will have the same type if and only if they contains the same atoms and the same bonds, in the same order.",72,[[["self"]],["moleculehash"]]],[11,"wrap","","Move all particles of a molecule such that the molecules center-of-mass position resides inside the simulation cell.",72,N],[11,"new","","Similar to `Vec<Particle> ::new()`",26,[[],["particlevec"]]],[11,"with_capacity","","Similar to `Vec<Particle> ::with_capacity()`,  initializing all fields with the given `capacity`.",26,[[["usize"]],["particlevec"]]],[11,"capacity","","Similar to `Vec<Particle> ::capacity()`,  the capacity of all fields should be the same.",26,[[["self"]],["usize"]]],[11,"reserve","","Similar to `Vec<Particle> ::reserve()`,  reserving the same `additional` space for all fields.",26,N],[11,"reserve_exact","","Similar to `Vec<Particle> ::reserve_exact()`  reserving the same `additional` space for all fields.",26,N],[11,"shrink_to_fit","","Similar to `Vec<Particle> ::shrink_to_fit()`  shrinking all fields.",26,N],[11,"truncate","","Similar to `Vec<Particle> ::truncate()`  truncating all fields.",26,N],[11,"push","","Similar to `Vec<Particle> ::push()`.",26,N],[11,"len","","Similar to `Vec<Particle> ::len()`,  all the fields should have the same length.",26,[[["self"]],["usize"]]],[11,"is_empty","","Similar to `Vec<Particle> ::is_empty()`,  all the fields should have the same length.",26,[[["self"]],["bool"]]],[11,"swap_remove","","Similar to `Vec<Particle> ::swap_remove()`.",26,[[["self"],["usize"]],["particle"]]],[11,"insert","","Similar to `Vec<Particle> ::insert()`.",26,N],[11,"remove","","Similar to `Vec<Particle> ::remove()`.",26,[[["self"],["usize"]],["particle"]]],[11,"pop","","Similar to `Vec<Particle> ::pop()`.",26,[[["self"]],["option",["particle"]]]],[11,"append","","Similar to `Vec<Particle> ::append()`.",26,N],[11,"clear","","Similar to `Vec<Particle> ::clear()`.",26,N],[11,"split_off","","Similar to `Vec<Particle> ::split_off()`.",26,[[["self"],["usize"]],["particlevec"]]],[11,"as_slice","","Similar to `Vec<Particle> ::as_slice()`.",26,[[["self"]],["particleslice"]]],[11,"as_mut_slice","","Similar to `Vec<Particle> ::as_mut_slice()`.",26,[[["self"]],["particleslicemut"]]],[11,"slice","","Create a slice of this vector matching the given `range`. This is analogous to `Index<Range<usize>>`.",26,[[["self"],["range",["usize"]]],["particleslice"]]],[11,"slice_mut","","Create a mutable slice of this vector matching the given `range`. This is analogous to `IndexMut<Range<usize>>`.",26,[[["self"],["range",["usize"]]],["particleslicemut"]]],[11,"retain","","Similar to `Vec<Particle> ::retain()`.",26,N],[11,"as_ptr","","Similar to `Vec<Particle> ::as_ptr()`.",26,[[["self"]],["particleptr"]]],[11,"as_mut_ptr","","Similar to `Vec<Particle> ::as_mut_ptr()`.",26,[[["self"]],["particleptrmut"]]],[11,"from_raw_parts","","Similar to `Vec<Particle> ::from_raw_parts()`.",26,[[["particleptrmut"],["usize"],["usize"]],["particlevec"]]],[11,"resize","","Similar to `Vec<Particle> ::resize()`.",26,N],[11,"iter","","Get an iterator over the `ParticleRef`  in this vector",26,[[["self"]],["iter"]]],[11,"iter_mut","","Get a mutable iterator over the `ParticleRefMut`  in this vector",26,[[["self"]],["itermut"]]],[11,"as_mut_ptr","","Convert a `ParticlePtr`  to a `ParticlePtrMut`  ; i.e. do a `*const T as *mut T` transformation.",27,[[["self"]],["particleptrmut"]]],[11,"is_null","","Similar to `*const T::is_null()`.",27,[[["self"]],["bool"]]],[11,"as_ref","","Similar to `*const T::as_ref()`, with the same safety caveats.",27,[[["self"]],["option",["particleref"]]]],[11,"offset","","Similar to `*const T::offset()`, with the same safety caveats.",27,[[["self"],["isize"]],["particleptr"]]],[11,"wrapping_offset","","Similar to `*const T::offset()`.",27,[[["self"],["isize"]],["particleptr"]]],[11,"add","","Similar to `*const T::add()`, with the same safety caveats.",27,[[["self"],["usize"]],["particleptr"]]],[11,"sub","","Similar to `*const T::sub()`, with the same safety caveats.",27,[[["self"],["usize"]],["particleptr"]]],[11,"wrapping_add","","Similar to `*const T::wrapping_add()`.",27,[[["self"],["usize"]],["particleptr"]]],[11,"wrapping_sub","","Similar to `*const T::wrapping_sub()`.",27,[[["self"],["usize"]],["particleptr"]]],[11,"read","","Similar to `*const T::read()`, with the same safety caveats.",27,[[["self"]],["particle"]]],[11,"read_volatile","","Similar to `*const T::read_volatile()`, with the same safety caveats.",27,[[["self"]],["particle"]]],[11,"read_unaligned","","Similar to `*const T::read_unaligned()`, with the same safety caveats.",27,[[["self"]],["particle"]]],[11,"new","","Create a new builder in read mode and with automatic format detection.",118,[[],["trajectorybuilder"]]],[11,"format","","Use a specific `format` when opening a file. See the [chemfiles] documentation for a format list.",118,[[["self"],["str"]],["trajectorybuilder"]]],[11,"mode","","Use a specific `mode` when opening a file.",118,[[["self"],["openmode"]],["trajectorybuilder"]]],[11,"open","","Open the trajectory at the given `path`.",118,[[["self"],["p"]],["result",["trajectory","error"]]]],[18,"ONE","","The particles are separated by one bond",51,N],[18,"TWO","","The particles are separated by two bonds",51,N],[18,"THREE","","The particles are separated by three bonds",51,N],[18,"FAR","","The particles are separated by more than three bonds",51,N],[11,"empty","","Returns an empty set of flags.",51,[[],["bonddistances"]]],[11,"all","","Returns the set containing all flags.",51,[[],["bonddistances"]]],[11,"bits","","Returns the raw value of the flags currently stored.",51,[[["self"]],["u8"]]],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",51,[[["u8"]],["option",["bonddistances"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",51,[[["u8"]],["bonddistances"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",51,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",51,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",51,[[["self"],["bonddistances"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",51,[[["self"],["bonddistances"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",51,N],[11,"remove","","Removes the specified flags in-place.",51,N],[11,"toggle","","Toggles the specified flags in-place.",51,N],[11,"set","","Inserts or removes the specified flags depending on the passed value.",51,N],[11,"new","","Create a new Angle between the particles at indexes `first`, `second` and `third`",90,[[["usize"],["usize"],["usize"]],["angle"]]],[11,"i","","Get the first particle in the angle",90,[[["self"]],["usize"]]],[11,"j","","Get the second particle in the angle",90,[[["self"]],["usize"]]],[11,"k","","Get the third particle in the angle",90,[[["self"]],["usize"]]],[11,"new","","Create a new `MoleculeRefMut` associating the given `bonding` and `particles`.",70,[[["bonding"],["particleslicemut"]],["moleculerefmut"]]],[11,"as_ref","","Borrow `self` as a `MoleculeRef`.",70,[[["self"]],["moleculeref"]]],[11,"particles","","Get access to the particles in this molecule",70,[[["self"]],["particleslice"]]],[11,"particles_mut","","Get mutable access to the particles in this molecule",70,[[["self"]],["particleslicemut"]]],[11,"to_owned","","Copies `self` into a new `Molecule`",70,[[["self"]],["molecule"]]],[11,"center_of_mass","","Return the center-of-mass of a molecule",70,[[["self"]],["vector3d"]]],[11,"hash","","Get a hash of this molecule. This is a hash of the particles names (in order), and the set of bonds in the molecule. This means that two molecules will have the same type if and only if they contains the same atoms and the same bonds, in the same order.",70,[[["self"]],["moleculehash"]]],[11,"wrap","","Move all particles of a molecule such that the molecules center-of-mass position resides inside the simulation cell.",70,N],[11,"read","","Read the next step of the trajectory",119,[[["self"]],["result",["system","error"]]]],[11,"read_guess_bonds","","Read the next step of the trajectory, and guess the bonds of the resulting [`System`][struct.System.html].",119,[[["self"]],["result",["system","error"]]]],[11,"write","","Write the system to the trajectory.",119,[[["self"],["system"]],["result",["error"]]]],[11,"set_cell","","Set the unit cell associated with a trajectory. This cell will be used when reading and writing the files, replacing any unit cell in the frames or files.",119,[[["self"],["unitcell"]],["result",["error"]]]],[11,"set_topology_file","","Set the topology associated with this trajectory by reading the first frame of the file at the given `path` and extracting the topology of this frame. This topology will be used to replace any existing topology when reading or writing with this trajectory.",119,[[["self"],["str"]],["result",["error"]]]],[11,"new","","Create a new empty energy cache.",120,[[],["energycache"]]],[11,"init","","Initialize the cache to be used with `system`. After a call to this function, the cache is only usable with the same system. To change the associated system, one must call this function again.",120,N],[11,"energy","","Get the cached energy",120,[[["self"]],["f64"]]],[11,"update","","Update the cache after a call to a `EnergyCache::*_cost` function or `EnergyCache::unused`.",120,N],[11,"unused","","This function should be called whenever the cache is not used, but one still want it to be updated. Future call to `EnergyCache::update` will recompute the full cache.",120,N],[11,"move_molecule_cost","","Get the cost of moving a rigid molecule at `molecule_id` in the system to `new_positions`.",120,N],[11,"move_all_molecules_cost","","Return the cost for moving all rigid molecules of the system.",120,[[["self"],["system"]],["f64"]]],[11,"as_ptr","","Convert a `ParticleRefMut`  to a `ParticlePtr`  ; i.e. do a `&mut T as *const T` transformation",30,[[["self"]],["particleptr"]]],[11,"as_mut_ptr","","Convert a `ParticleRefMut`  to a `ParticlePtrMut`  ; i.e. do a `&mut T as *mut T` transformation",30,[[["self"]],["particleptrmut"]]],[11,"as_ref","","Convert a `ParticleSliceMut`  to a `ParticleSlice`  in order to be able to use the methods on the non mutable  version of the slices.",31,[[["self"]],["particleslice"]]],[11,"len","","Similar to `[Particle] ::len()`,  the length of all fields should be the same.",31,[[["self"]],["usize"]]],[11,"is_empty","","Similar to `[Particle] ::is_empty()`,  the length of all fields should be the same.",31,[[["self"]],["bool"]]],[11,"first_mut","","Similar to `[Particle] ::first_mut()`.",31,[[["self"]],["option",["particlerefmut"]]]],[11,"split_first_mut","","Similar to `[Particle] ::split_first_mut()`.",31,[[["self"]],["option"]]],[11,"last_mut","","Similar to `[Particle] ::last_mut()`.",31,[[["self"]],["option",["particlerefmut"]]]],[11,"split_last_mut","","Similar to `[Particle] ::last_mut()`.",31,[[["self"]],["option"]]],[11,"split_at_mut","","Similar to `[Particle] ::split_at_mut()`.",31,N],[11,"swap","","Similar to `[Particle] ::swap()`.",31,N],[11,"get","","Similar to `[Particle] ::get()`.",31,[[["self"],["usize"]],["option",["particleref"]]]],[11,"get_unchecked","","Similar to `[Particle] ::get_unchecked()`.",31,[[["self"],["usize"]],["particleref"]]],[11,"get_mut","","Similar to `[Particle] ::get_mut()`.",31,[[["self"],["usize"]],["option",["particlerefmut"]]]],[11,"get_unchecked_mut","","Similar to `[Particle] ::get_unchecked_mut()`.",31,[[["self"],["usize"]],["particlerefmut"]]],[11,"as_ptr","","Similar to `[Particle] ::as_ptr()`.",31,[[["self"]],["particleptr"]]],[11,"as_mut_ptr","","Similar to `[Particle] ::as_mut_ptr()`.",31,[[["self"]],["particleptrmut"]]],[11,"from_raw_parts_mut","","Similar to `std::slice::from_raw_parts_mut()`.",31,[[["particleptrmut"],["usize"]],["particleslicemut"]]],[11,"to_vec","","Similar to `[Particle] ::to_vec()`.",31,[[["self"]],["particlevec"]]],[11,"iter","","Get an iterator over the `ParticleRef`  in this vector",31,[[["self"]],["iter"]]],[11,"iter_mut","","Get a mutable iterator over the `ParticleRefMut`  in this vector",31,[[["self"]],["itermut"]]],[11,"new","","Create a new `MoleculeRef` associating the given `bonding` and `particles`.",71,[[["bonding"],["particleslice"]],["moleculeref"]]],[11,"particles","","Get access to the particles in this molecule",71,[[["self"]],["particleslice"]]],[11,"to_owned","","Copies `self` into a new `Molecule`",71,[[["self"]],["molecule"]]],[11,"center_of_mass","","Return the center-of-mass of a molecule",71,[[["self"]],["vector3d"]]],[11,"hash","","Get a hash of this molecule. This is a hash of the particles names (in order), and the set of bonds in the molecule. This means that two molecules will have the same type if and only if they contains the same atoms and the same bonds, in the same order.",71,[[["self"]],["moleculehash"]]],[11,"as_ptr","","Convert a `ParticleRef`  to a `ParticlePtr`  ; i.e. do a `&T as *const T` transformation",32,[[["self"]],["particleptr"]]],[11,"new","","Create a new empty `System`",33,[[],["system"]]],[11,"with_cell","","Create an empty system with a specific unit cell",33,[[["unitcell"]],["system"]]],[11,"add_molecule","","Add a molecule to the system",33,N],[11,"composition","","Get the composition in particles and molecules of the configuration",33,[[["self"]],["composition"]]],[11,"simulated_temperature","","Use an external temperature for all the system properties. Calling this with `Some(temperature)` will replace all the computation of the temperature from the velocities with the given values. Calling it with `None` will use the velocities.",33,N],[11,"energy_evaluator","","Get an helper struct to evaluate the energy of this system.",33,[[["self"]],["energyevaluator"]]],[11,"add_pair_potential","","Add the `potential` pair interaction for atoms with types `i` and `j`",33,N],[11,"add_bond_potential","","Add the `potential` bonded interaction for atoms with types `i` and `j`",33,N],[11,"add_angle_potential","","Add the `potential` angle interaction for the angle `(i, j, k)`",33,N],[11,"add_dihedral_potential","","Add the `potential` dihedral interaction for the dihedral angle `(i, j, k, m)`",33,N],[11,"set_coulomb_potential","","Set the coulombic interaction for all pairs to `potential`",33,N],[11,"add_global_potential","","Add the `potential` global interaction",33,N],[11,"pair_potentials","","Get the list of pair potential acting between the particles at indexes `i` and `j`.",33,N],[11,"bond_potentials","","Get the list of bonded potential acting between the particles at indexes `i` and `j`.",33,N],[11,"angle_potentials","","Get the list of angle interaction acting between the particles at indexes `i`, `j` and `k`.",33,N],[11,"dihedral_potentials","","Get the list of dihedral angles interaction acting between the particles at indexes `i`, `j`, `k` and `m`.",33,N],[11,"coulomb_potential","","Get the coulombic interaction for the system",33,[[["self"]],["option",["coulombicpotential"]]]],[11,"global_potentials","","Get all global interactions for the system",33,N],[11,"maximum_cutoff","","Get maximum cutoff from `coulomb`, `pairs` and `global` interactions.",33,[[["self"]],["option",["f64"]]]],[11,"degrees_of_freedom","","Get the number of degrees of freedom in the system",33,[[["self"]],["usize"]]],[11,"kinetic_energy","","Get the kinetic energy of the system.",33,[[["self"]],["f64"]]],[11,"potential_energy","","Get the potential energy of the system.",33,[[["self"]],["f64"]]],[11,"total_energy","","Get the total energy of the system.",33,[[["self"]],["f64"]]],[11,"temperature","","Get the temperature of the system.",33,[[["self"]],["f64"]]],[11,"volume","","Get the volume of the system.",33,[[["self"]],["f64"]]],[11,"virial","","Get the virial of the system as a tensor",33,[[["self"]],["matrix3"]]],[11,"pressure","","Get the pressure of the system from the virial equation, at the system instantaneous temperature.",33,[[["self"]],["f64"]]],[11,"stress","","Get the stress tensor of the system from the virial equation.",33,[[["self"]],["matrix3"]]],[11,"forces","","Get the forces acting on all the particles in the system",33,[[["self"]],["vec",["vector3d"]]]],[11,"new","lumol::sim::output","Create a new `TrajectoryOutput` writing to `filename`. The file is replaced if it already exists. The file format is guessed from the extension. Please refer to the list of [supported formats][formats] for more information.",109,[[["p"]],["result",["trajectoryoutput","error"]]]],[11,"with_format","","Create a new `TrajectoryOutput` writing to `filename` using the given `format`. The file is replaced if it already exists.",109,[[["p"],["str"]],["result",["trajectoryoutput","error"]]]],[11,"new","","Create a new `CellOutput` writing to `filename`. The file is replaced if it already exists.",100,[[["p"]],["result",["celloutput","error"]]]],[11,"new","","Create a new `StressOutput` writing to `filename`. The file is replaced if it already exists.",111,[[["p"]],["result",["stressoutput","error"]]]],[11,"new","","Create a new `ForcesOutput` writing to `filename`. The file is replaced if it already exists.",106,[[["p"]],["result",["forcesoutput","error"]]]],[11,"new","","Create a new `PropertiesOutput` writing to `filename`. The file is replaced if it already exists.",110,[[["p"]],["result",["propertiesoutput","error"]]]],[11,"new","","Create a new `CustomOutput` writing to the file at `filename` using the given `template`. The `template` is only partially validated at this stage.",103,[[["p"],["str"]],["result",["customoutput","customoutputerror"]]]],[11,"new","","Create a new `EnergyOutput` writing to `filename`. The file is replaced if it already exists.",108,[[["p"]],["result",["energyoutput","error"]]]],[11,"new","lumol::sim::md","Create a new `RescaleThermostat` acting at temperature `temperature`, with a tolerance of `5% * temperature`.",104,[[["f64"]],["rescalethermostat"]]],[11,"with_tolerance","","Create a new `RescaleThermostat` acting at temperature `T`, with a tolerance of `tol`. For rescaling all the steps, use `tol = 0`.",104,[[["f64"],["f64"]],["rescalethermostat"]]],[11,"new","","Create a new `RemoveTranslation` control.",114,[[],["removetranslation"]]],[11,"new","","Create a new `MolecularDynamics` propagator using a `VelocityVerlet` integrator.",107,[[["f64"]],["moleculardynamics"]]],[11,"from_integrator","","Create a new `MolecularDynamics` propagator using the specified `integrator`.",107,[[["box",["integrator"]]],["moleculardynamics"]]],[11,"add_control","","Add a control algorithm to the internal list of controls.",107,N],[11,"set_thermostat","","Set the thermostat to use with this simulation",107,N],[11,"new","","Create a new integrator with a timestep of `timestep`.",95,[[["f64"]],["leapfrog"]]],[11,"new","","Create a new integrator with a timestep of `timestep`.",98,[[["f64"]],["verlet"]]],[11,"new","","Create a new Berendsen barostat with an integration timestep of `timestep`, and a target pressure of `pressure` and the barostat time scale `tau`.",99,[[["f64"],["f64"],["f64"]],["berendsenbarostat"]]],[11,"new","","Create a new anisotropic Berendsen barostat with an integration timestep of `timestep`, and a target stress matrix of `stress` and the barostat time scale `tau`.",96,[[["f64"],["matrix3"],["f64"]],["anisoberendsenbarostat"]]],[11,"hydrostatic","","Create a new anisotropic Berendsen barostat with an integration timestep of `timestep`, using an hydrostatic stress matrix corresponding to the pressure `pressure` and the barostat time scale `tau`.",96,[[["f64"],["f64"],["f64"]],["anisoberendsenbarostat"]]],[11,"new","","Create a new `BerendsenThermostat` acting at temperature `T`, with a timestep of `tau` times the integrator timestep.",105,[[["f64"],["f64"]],["berendsenthermostat"]]],[11,"new","","Create a new integrator with a timestep of `timestep`.",92,[[["f64"]],["velocityverlet"]]],[11,"new","","Create a new `RemoveRotation` control.",116,[[],["removerotation"]]],[11,"new","","Create a new `RemoveRotation` control.",115,[[],["rewrap"]]],[11,"new","lumol::sim::mc","Create a new Monte Carlo propagator at temperature `T`.",94,[[["f64"]],["montecarlo"]]],[11,"from_rng","","Create a Monte Carlo propagator at temperature `T`, using the `rng` random number generator.",94,[[["f64"],["box",["rngcore"]]],["montecarlo"]]],[11,"add","","Add the `mcmove` Monte Carlo move to this propagator, with frequency `frequency`. All calls to this function should happen before any simulation run.",94,N],[11,"add_move_with_acceptance","","Add the `mcmove` Monte Carlo move to the propagator. `frequency` describes how frequent a move is called, `target_acceptance` is the desired acceptance ratio of the move.",94,N],[11,"set_amplitude_update_frequency","","Set the number of times a move has to be called before its amplitude is updated. This value is applied to all moves.",94,N],[11,"temperature","","Get the temperature of the simulation",94,[[["self"]],["f64"]]],[11,"set_temperature","","Set the temperature of the simulation",94,N],[11,"combine","","Combine the degrees of freedom represented by this `MCDegreeOfFreedom` and `other`",38,[[["self"],["mcdegreeoffreedom"]],["mcdegreeoffreedom"]]],[11,"new","","Create a new `Translate` move, with maximum displacement of `delta`. This move will apply to the molecules with the given `hash`, or all molecules if `hash` is `None`.",97,[[["f64"],["h"]],["translate"]]],[11,"new","","Create a new `Resize` move, with target pressure `pressure` and maximum displacement of `delta`.",91,[[["f64"],["f64"]],["resize"]]],[11,"new","","Create a new `Rotate` move, with maximum angular displacement of `theta`. This move will apply to the molecules with the given `hash`, or all molecules if `hash` is `None`.",93,[[["f64"],["h"]],["rotate"]]],[11,"new","","Create a new counter for the move, initializing all counts to zero and setting the `target_acceptance`.",40,[[["option",["f64"]]],["movecounter"]]],[11,"set_acceptance","","Set the target acceptance for the move counter.",40,N],[11,"reject","","Increase counters for attempt.",40,N],[11,"accept","","Increase counters to track the number of times the move was accepted.",40,N],[11,"update","","Reset counters for attempts and acceptance since the last update.",40,N],[11,"acceptance","","Return fraction of total number of accepted over total number of attempted moves.",40,[[["self"]],["f64"]]],[11,"compute_scaling_factor","","Compute a scaling factor according to the desired acceptance.",40,[[["self"]],["option",["f64"]]]],[11,"new","lumol::sim::min","Create a new `Minimization` using the given `minimizer` and specific energy and force `tolerance`.",101,[[["box",["minimizer"]],["tolerance"]],["minimization"]]],[11,"converged","","Check if the minimization has converged.",101,[[["self"]],["bool"]]],[11,"new","","Create a new `SteepestDescent` minimizer",102,[[],["steepestdescent"]]],[11,"new","lumol::sim","Create a new `BoltzmannVelocities` at the given `temperature`.",112,[[["f64"]],["boltzmannvelocities"]]],[11,"new","","Create a new `UniformVelocities` at the given `temperature`.",113,[[["f64"]],["uniformvelocities"]]],[11,"new","","Create a new Simulation from a Propagator.",121,[[["box",["propagator"]]],["simulation"]]],[11,"run","","Run the simulation on System for `nsteps` steps.",121,N],[11,"add_output","","Add a new `Output` algorithm in the outputs list",121,N],[11,"add_output_with_frequency","","Add a new `Output` algorithm in the outputs list, which will be used at the given frequency. The output will be used every time the system step matches this frequency.",121,N],[11,"read_system","lumol::input","Get the the simulated system.",122,[[["self"]],["result",["system","error"]]]],[11,"read_simulation","","Get the the simulation.",122,[[["self"]],["result",["simulation","error"]]]],[11,"new","","Read the file at `Path` and create a new `Input` from it.",122,[[["p"]],["result",["input","error"]]]],[11,"from_str","","Read the `Input` from a TOML formatted string.",122,[[["pathbuf"],["str"]],["result",["input","error"]]]],[11,"read","","Read input file and get the corresponding `Config`",122,[[["self"]],["result",["config","error"]]]],[11,"new","","Read interactions from the TOML formatted file at `path`.",123,[[["p"]],["result",["input","error"]]]],[11,"from_str","","Read the interactions from a TOML formatted string.",123,[[["str"]],["result",["input","error"]]]],[11,"read","","Read the interactions from this input into the `system`.",123,[[["self"],["system"]],["result",["error"]]]]],"paths":[[4,"ParseError"],[8,"Potential"],[8,"PairPotential"],[8,"BondPotential"],[3,"Buckingham"],[4,"BondPath"],[8,"GlobalPotential"],[3,"BornMayerHuggins"],[3,"Torsion"],[8,"GlobalCache"],[3,"Morse"],[3,"LennardJones"],[3,"RestrictionInfo"],[4,"PairRestriction"],[8,"Computation"],[8,"CoulombicPotential"],[3,"Harmonic"],[8,"Compute"],[3,"PressureAtTemperature"],[3,"StressAtTemperature"],[3,"ParticleSlice"],[4,"CellShape"],[3,"ParticleKind"],[3,"Particle"],[3,"ParticlePtrMut"],[4,"OpenMode"],[3,"ParticleVec"],[3,"ParticlePtr"],[3,"Configuration"],[4,"DegreesOfFreedom"],[3,"ParticleRefMut"],[3,"ParticleSliceMut"],[3,"ParticleRef"],[3,"System"],[8,"Output"],[4,"CustomOutputError"],[8,"Control"],[8,"Integrator"],[4,"MCDegreeOfFreedom"],[8,"MCMove"],[3,"MoveCounter"],[8,"Minimizer"],[3,"Tolerance"],[4,"TemperatureStrategy"],[8,"Propagator"],[8,"InitVelocities"],[8,"FromToml"],[8,"FromTomlWithData"],[8,"FromTomlWithRefData"],[3,"Config"],[4,"Error"],[3,"BondDistances"],[3,"TrajectoryError"],[3,"Vector3D"],[3,"Complex"],[3,"Array2"],[3,"Matrix3"],[3,"Array3"],[3,"TotalEnergy"],[3,"PotentialEnergy"],[3,"KineticEnergy"],[3,"Pressure"],[3,"Stress"],[3,"Virial"],[3,"MolecularVirial"],[3,"AtomicVirial"],[3,"Forces"],[3,"Temperature"],[3,"Volume"],[3,"Bonding"],[3,"MoleculeRefMut"],[3,"MoleculeRef"],[3,"Molecule"],[3,"CONVERSION_FACTORS"],[3,"Ewald"],[3,"SharedEwald"],[3,"Wolf"],[3,"MoleculeIterMut"],[3,"MoleculeIter"],[3,"CosineHarmonic"],[3,"TableComputation"],[3,"Mie"],[3,"Composition"],[3,"Gaussian"],[3,"MoleculeHash"],[3,"NullPotential"],[3,"UnitCell"],[3,"Dihedral"],[3,"PairInteraction"],[3,"Bond"],[3,"Angle"],[3,"Resize"],[3,"VelocityVerlet"],[3,"Rotate"],[3,"MonteCarlo"],[3,"LeapFrog"],[3,"AnisoBerendsenBarostat"],[3,"Translate"],[3,"Verlet"],[3,"BerendsenBarostat"],[3,"CellOutput"],[3,"Minimization"],[3,"SteepestDescent"],[3,"CustomOutput"],[3,"RescaleThermostat"],[3,"BerendsenThermostat"],[3,"ForcesOutput"],[3,"MolecularDynamics"],[3,"EnergyOutput"],[3,"TrajectoryOutput"],[3,"PropertiesOutput"],[3,"StressOutput"],[3,"BoltzmannVelocities"],[3,"UniformVelocities"],[3,"RemoveTranslation"],[3,"Rewrap"],[3,"RemoveRotation"],[3,"EnergyEvaluator"],[3,"TrajectoryBuilder"],[3,"Trajectory"],[3,"EnergyCache"],[3,"Simulation"],[3,"Input"],[3,"InteractionsInput"]]};
initSearch(searchIndex);
